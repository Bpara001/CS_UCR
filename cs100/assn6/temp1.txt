 
 
 
 
 
 
 
 
 


 
#ifndef _GLIBCXX_IOSTREAM 
 
#pragma GCC system_header 
 
#ifndef _CPP_CPPCONFIG_WRAPPER 

#if __WORDSIZE == 32 
 
 
 
 
 
#ifndef _CXXCONFIG 
 
 
 
 
 
 
#ifndef _GLIBCXX_OS_DEFINES 
 
 
 


 
#ifndef	_FEATURES_H 
#define	_FEATURES_H	1 
 


 
 


#ifndef _LOOSE_KERNEL_NAMES 
# define __KERNEL_STRICT_NAMES 
#endif 
 


#if defined __GNUC__ && defined __GNUC_MINOR__ 
# define __GNUC_PREREQ(maj, min) \ 
	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min)) 
#else 
# define __GNUC_PREREQ(maj, min) 0 
#endif 
 
 


#ifdef _GNU_SOURCE 
# undef  _ISOC99_SOURCE 
# define _ISOC99_SOURCE	1 
# undef  _POSIX_SOURCE 
# define _POSIX_SOURCE	1 
# undef  _POSIX_C_SOURCE 
# define _POSIX_C_SOURCE	200112L 
# undef  _XOPEN_SOURCE 
# define _XOPEN_SOURCE	600 
# undef  _XOPEN_SOURCE_EXTENDED 
# define _XOPEN_SOURCE_EXTENDED	1 
# undef	 _LARGEFILE64_SOURCE 
# define _LARGEFILE64_SOURCE	1 
# undef  _BSD_SOURCE 
# define _BSD_SOURCE	1 
# undef  _SVID_SOURCE 
# define _SVID_SOURCE	1 
# undef  _ATFILE_SOURCE 
# define _ATFILE_SOURCE	1 
#endif 
 


#if (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && \ 
     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE && \ 
     !defined _XOPEN_SOURCE && !defined _XOPEN_SOURCE_EXTENDED && \ 
     !defined _BSD_SOURCE && !defined _SVID_SOURCE) 
# define _BSD_SOURCE	1 
# define _SVID_SOURCE	1 
#endif 
 


#if (defined _ISOC99_SOURCE || defined _ISOC9X_SOURCE \ 
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)) 
# define __USE_ISOC99	1 
#endif 
 


#if ((!defined __STRICT_ANSI__ || (_XOPEN_SOURCE - 0) >= 500) && \ 
     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE) 
# define _POSIX_SOURCE	1 
# if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500 
#  define _POSIX_C_SOURCE	2 
# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600 
#  define _POSIX_C_SOURCE	199506L 
# else 
#  define _POSIX_C_SOURCE	200112L 
# endif 
#endif 
 
#if defined _POSIX_SOURCE || _POSIX_C_SOURCE >= 1 || defined _XOPEN_SOURCE 
# define __USE_POSIX	1 
#endif 
 
#if defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCE 
# define __USE_POSIX2	1 
#endif 
 
#if (_POSIX_C_SOURCE - 0) >= 199309L 
# define __USE_POSIX199309	1 
#endif 
 
#if (_POSIX_C_SOURCE - 0) >= 199506L 
# define __USE_POSIX199506	1 
#endif 
 
#if (_POSIX_C_SOURCE - 0) >= 200112L 
# define __USE_XOPEN2K		1 
#endif 
 
#ifdef	_XOPEN_SOURCE 
# define __USE_XOPEN	1 
# if (_XOPEN_SOURCE - 0) >= 500 
#  define __USE_XOPEN_EXTENDED	1 
#  define __USE_UNIX98	1 
#  undef _LARGEFILE_SOURCE 
#  define _LARGEFILE_SOURCE	1 
#  if (_XOPEN_SOURCE - 0) >= 600 
#   define __USE_XOPEN2K	1 
#   undef __USE_ISOC99 
#   define __USE_ISOC99		1 
#  endif 
# else 
#  ifdef _XOPEN_SOURCE_EXTENDED 
#   define __USE_XOPEN_EXTENDED	1 
#  endif 
# endif 
#endif 
 
#ifdef _LARGEFILE_SOURCE 
# define __USE_LARGEFILE	1 
#endif 
 
#ifdef _LARGEFILE64_SOURCE 
# define __USE_LARGEFILE64	1 
#endif 
 
#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64 
# define __USE_FILE_OFFSET64	1 
#endif 
 
#if defined _BSD_SOURCE || defined _SVID_SOURCE 
# define __USE_MISC	1 
#endif 
 
#ifdef	_BSD_SOURCE 
# define __USE_BSD	1 
#endif 
 
#ifdef	_SVID_SOURCE 
# define __USE_SVID	1 
#endif 
 
#ifdef	_ATFILE_SOURCE 
# define __USE_ATFILE	1 
#endif 
 
#ifdef	_GNU_SOURCE 
# define __USE_GNU	1 
#endif 
 
#if defined _REENTRANT || defined _THREAD_SAFE 
# define __USE_REENTRANT	1 
#endif 
 
#if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 \ 
    && defined __OPTIMIZE__ && __OPTIMIZE__ > 0 \ 
    && (__GNUC_PREREQ (4, 1) \ 
        || (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (4, 0)) \ 
        || (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (3, 4) \ 
            && __GNUC_MINOR__ == 4 \ 
            && (__GNUC_PATCHLEVEL__ > 2 \ 
                || (__GNUC_PATCHLEVEL__ == 2 && __GNUC_RH_RELEASE__ >= 8)))) 
# if _FORTIFY_SOURCE > 1 
#  define __USE_FORTIFY_LEVEL 2 
# else 
#  define __USE_FORTIFY_LEVEL 1 
# endif 
#else 
# define __USE_FORTIFY_LEVEL 0 
#endif 
 


 


#undef  __GNU_LIBRARY__ 
 


#define	__GLIBC__	2 
#define	__GLIBC_MINOR__	5 
 
	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min)) 
 


#ifndef __ASSEMBLER__ 
# ifndef _SYS_CDEFS_H 
#  include <sys/cdefs.h> 
# endif 
 


# if defined __USE_FILE_OFFSET64 && !defined __REDIRECT 
#  define __USE_LARGEFILE	1 
#  define __USE_LARGEFILE64	1 
# endif 
 
#endif	

#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \ 
    && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__ 
# define __USE_EXTERN_INLINES	1 
#endif 
 
 




 
 
#if __WORDSIZE == 32 
# include <gnu/stubs-32.h> 
#elif __WORDSIZE == 64 
# include <gnu/stubs-64.h> 
#else 
# error "unexpected value for __WORDSIZE macro" 
#endif 
 
 
 
#endif	
 
#if defined __GLIBC__ && __GLIBC__ >= 2 
#endif 
 
#endif 
 
 
 
 
 
 
 
#ifndef _GLIBCXX_CPU_DEFINES 
 
#endif 
 
 
namespace __gnu_debug_def { } 
 
namespace __gnu_debug  
{  
  using namespace __gnu_debug_def; 
} 
 
#ifdef _GLIBCXX_DEBUG 
# define _GLIBCXX_STD __gnu_norm 
# define _GLIBCXX_EXTERN_TEMPLATE 0 
namespace __gnu_norm  
{  
  using namespace std;  
} 
namespace std 
{ 
  using namespace __gnu_debug_def __attribute__ ((strong)); 
} 
# if __NO_INLINE__ && !__GXX_WEAK__ 
#  warning debug mode without inlining may fail due to lack of weak symbols 
# endif 
#else 
# define _GLIBCXX_STD std 
#endif 
 




 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 




 








 


 


 




 


 


 


 


 


 


 


































































































































 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 




 


 


 


 


 


 


#undef _GLIBCXX_LONG_DOUBLE_COMPAT 
 
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
# define _GLIBCXX_LDBL_NAMESPACE __gnu_cxx_ldbl128:: 
# define _GLIBCXX_BEGIN_LDBL_NAMESPACE namespace __gnu_cxx_ldbl128 { 
# define _GLIBCXX_END_LDBL_NAMESPACE } 
namespace std 
{ 
  namespace __gnu_cxx_ldbl128 { } 
  using namespace __gnu_cxx_ldbl128 __attribute__((__strong__)); 
} 
#else 
# define _GLIBCXX_LDBL_NAMESPACE 
# define _GLIBCXX_BEGIN_LDBL_NAMESPACE 
# define _GLIBCXX_END_LDBL_NAMESPACE 
#endif 
 
 
#ifndef _GLIBCXX_EXTERN_TEMPLATE 
# define _GLIBCXX_EXTERN_TEMPLATE 1 
#endif 
 
#ifndef _GLIBCXX_WEAK_DEFINITION 
# define _GLIBCXX_WEAK_DEFINITION 
#endif 
 
 
#ifdef __FAST_MATH__ 
# define _GLIBCXX_FAST_MATH 1 
#else 
# define _GLIBCXX_FAST_MATH 0 
#endif 
 
 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 






 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 




 








 


 


 




 


 


 


 


 


 


 


































































































































 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 






 


 


 


 


 


 

 
 
 
 
 
 


 
#ifndef _GLIBCXX_OSTREAM 
 
#pragma GCC system_header 
 
 
 
 
 
 
 


 
#ifndef _GLIBCXX_IOS 
 
#pragma GCC system_header 
 
 
 
 
 
 
 


 
#ifndef _GLIBCXX_IOSFWD 
 
#pragma GCC system_header 
 
 
 
 
 
 
 
 
#ifndef _C_LOCALE_H 
 
#pragma GCC system_header 
 
#include <cstring>              #include <cstdio>                
#ifndef __CLOCALE_HEADER 
 


 


 
#ifndef	_LOCALE_H 
#define	_LOCALE_H	1 
 
 
#ifndef _LINUX_STDDEF_H 
 
 
#undef NULL 
#if defined(__cplusplus) 
#else 
#endif 
 
 
#endif 
 
 
__BEGIN_DECLS 
 


#define	LC_ALL		  __LC_ALL 
 
 


 
  char *decimal_point;		

  

  char *grouping; 
 
  

  char *int_curr_symbol; 
  char *currency_symbol;	

  char *mon_thousands_sep;	

  char *positive_sign;		

  char int_frac_digits;		

  

  char p_sep_by_space; 
  

  char n_sep_by_space; 
  

  char p_sign_posn; 
  char n_sign_posn; 
#ifdef __USE_ISOC99 
  

  char int_p_sep_by_space; 
  

  char int_n_sep_by_space; 
  

  char int_p_sign_posn; 
  char int_n_sign_posn; 
#else 
  char __int_p_cs_precedes; 
  char __int_p_sep_by_space; 
  char __int_n_cs_precedes; 
  char __int_n_sep_by_space; 
  char __int_p_sign_posn; 
  char __int_n_sign_posn; 
#endif 
}; 
 
 
__BEGIN_NAMESPACE_STD 
 


extern struct lconv *localeconv (void) __THROW; 
 
__END_NAMESPACE_STD 
 
 
#ifdef	__USE_GNU 


 


extern __locale_t newlocale (int __category_mask, __const char *__locale, 
			     __locale_t __base) __THROW; 
 


# define LC_CTYPE_MASK		(1 << __LC_CTYPE) 
# define LC_NUMERIC_MASK	(1 << __LC_NUMERIC) 
# define LC_TIME_MASK		(1 << __LC_TIME) 
# define LC_COLLATE_MASK	(1 << __LC_COLLATE) 
# define LC_MONETARY_MASK	(1 << __LC_MONETARY) 
# define LC_MESSAGES_MASK	(1 << __LC_MESSAGES) 
# define LC_PAPER_MASK		(1 << __LC_PAPER) 
# define LC_NAME_MASK		(1 << __LC_NAME) 
# define LC_ADDRESS_MASK	(1 << __LC_ADDRESS) 
# define LC_TELEPHONE_MASK	(1 << __LC_TELEPHONE) 
# define LC_MEASUREMENT_MASK	(1 << __LC_MEASUREMENT) 
# define LC_IDENTIFICATION_MASK	(1 << __LC_IDENTIFICATION) 
# define LC_ALL_MASK		(LC_CTYPE_MASK \ 
				 | LC_NUMERIC_MASK \ 
				 | LC_TIME_MASK \ 
				 | LC_COLLATE_MASK \ 
				 | LC_MONETARY_MASK \ 
				 | LC_MESSAGES_MASK \ 
				 | LC_PAPER_MASK \ 
				 | LC_NAME_MASK \ 
				 | LC_ADDRESS_MASK \ 
				 | LC_TELEPHONE_MASK \ 
				 | LC_MEASUREMENT_MASK \ 
				 | LC_IDENTIFICATION_MASK \ 
				 ) 
 


extern __locale_t duplocale (__locale_t __dataset) __THROW; 
 


extern void freelocale (__locale_t __dataset) __THROW; 
 


extern __locale_t uselocale (__locale_t __dataset) __THROW; 
 


# define LC_GLOBAL_LOCALE	((__locale_t) -1L) 
 
#endif 
 
__END_DECLS 
 
#endif 
 
namespace std { 
  using ::lconv; 
  using ::localeconv; 
  using ::setlocale; 
} 
 
#endif  
#include <langinfo.h>		#include <iconv.h>		#include <libintl.h> 		 
 
 
#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) 
namespace __gnu_cxx 
{ 
  extern "C" __typeof(uselocale) __uselocale; 
} 
#endif 
 
namespace std 
{ 
  typedef __locale_t		__c_locale; 
 
          template<typename _Tv> 
    int 
    __convert_from_v(char* __out,  
		     const int __size __attribute__ ((__unused__)), 
		     const char* __fmt, 
#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) 
		     _Tv __v, const __c_locale& __cloc, int __prec) 
    { 
      __c_locale __old = __gnu_cxx::__uselocale(__cloc); 
#else 
		     _Tv __v, const __c_locale&, int __prec) 
    { 
      char* __old = std::setlocale(LC_ALL, NULL); 
      char* __sav = new char[std::strlen(__old) + 1]; 
      std::strcpy(__sav, __old); 
      std::setlocale(LC_ALL, "C"); 
#endif 
 
#ifdef 1 
      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v); 
#else 
      const int __ret = std::sprintf(__out, __fmt, __prec, __v); 
#endif 
 
#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) 
      __gnu_cxx::__uselocale(__old); 
#else 
      std::setlocale(LC_ALL, __sav); 
      delete [] __sav; 
#endif 
      return __ret; 
    } 
} 
 
#endif 
 
 
 
 
 
 
 
#ifndef _C_IO_STDIO_H 
 
 
#ifndef __CSTDIO_HEADER 
 


 


 
#ifndef _STDIO_H 
 
#if !defined __need_FILE && !defined __need___FILE 
# define _STDIO_H	1 
# include <features.h> 
 
__BEGIN_DECLS 
 
# define __need_size_t 
# define #define __need_NULL 
# include <stddef.h> 
 
# include <bits/types.h> 
# define __need_FILE 
# define __need___FILE 
#endif 

typedef struct _IO_FILE FILE; 
__END_NAMESPACE_STD 
#if defined __USE_LARGEFILE64 || defined __USE_SVID || defined __USE_POSIX \ 
    || defined __USE_BSD || defined __USE_ISOC99 || defined __USE_XOPEN \ 
    || defined __USE_POSIX2 
__USING_NAMESPACE_STD(FILE) 
#endif 
 
# define __FILE_defined	1 
#endif 

typedef struct _IO_FILE __FILE; 
 
# define ____FILE_defined	1 
#endif 

__BEGIN_NAMESPACE_STD 
#ifndef __USE_FILE_OFFSET64 
typedef _G_fpos_t fpos_t; 
#else 
typedef _G_fpos64_t fpos_t; 
#endif 
__END_NAMESPACE_STD 
#ifdef __USE_LARGEFILE64 
typedef _G_fpos64_t fpos64_t; 
#endif 
 


#define _IOLBF 1		

 
 


#ifndef EOF 
# define EOF (-1) 
#endif 
 
 


#define SEEK_SET	0	

#define SEEK_END	2	

# define P_tmpdir	"/tmp" 
#endif 
 
 




 
#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX 
# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead." 
#endif 
 
#ifdef _STDIO_H 
# define L_tmpnam 20 
# define TMP_MAX 238328 
# define FILENAME_MAX 4096 
 
# ifdef __USE_POSIX 
#  define L_ctermid 9 
#  define L_cuserid 9 
# endif 
#endif 
 
#if defined __need_FOPEN_MAX || defined _STDIO_H 
# undef  FOPEN_MAX 
# define FOPEN_MAX 16 
#endif 
 
#if defined __need_IOV_MAX && !defined IOV_MAX 
# define IOV_MAX 1024 
#endif 
 
 
 


extern struct _IO_FILE *stdout;		

#ifdef __STDC__ 


extern int remove (__const char *__filename) __THROW; 


extern int renameat (int __oldfd, __const char *__old, int __newfd, 
		     __const char *__new) __THROW; 
#endif 
 
__BEGIN_NAMESPACE_STD 


#ifndef __USE_FILE_OFFSET64 
extern FILE *tmpfile (void); 
#else 
# ifdef __REDIRECT 
extern FILE *__REDIRECT (tmpfile, (void), tmpfile64); 
# else 
#  define tmpfile tmpfile64 
# endif 
#endif 
 
#ifdef __USE_LARGEFILE64 
extern FILE *tmpfile64 (void); 
#endif 
 


extern char *tmpnam_r (char *__s) __THROW; 
#endif 
 
 
#if defined __USE_SVID || defined __USE_XOPEN 


extern char *tempnam (__const char *__dir, __const char *__pfx) 
     __THROW __attribute_malloc__; 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern int fclose (FILE *__stream); 


extern int fflush (FILE *__stream); 
__END_NAMESPACE_STD 
 
#ifdef __USE_MISC 


extern int fflush_unlocked (FILE *__stream); 
#endif 
 
#ifdef __USE_GNU 


extern int fcloseall (void); 
#endif 
 
 
__BEGIN_NAMESPACE_STD 
#ifndef __USE_FILE_OFFSET64 


extern FILE *fopen (__const char *__restrict __filename, 
		    __const char *__restrict __modes); 


extern FILE *freopen (__const char *__restrict __filename, 
		      __const char *__restrict __modes, 
		      FILE *__restrict __stream); 
#else 
# ifdef __REDIRECT 
extern FILE *__REDIRECT (fopen, (__const char *__restrict __filename, 
				 __const char *__restrict __modes), fopen64); 
extern FILE *__REDIRECT (freopen, (__const char *__restrict __filename, 
				   __const char *__restrict __modes, 
				   FILE *__restrict __stream), freopen64); 
# else 
#  define fopen fopen64 
#  define freopen freopen64 
# endif 
#endif 
__END_NAMESPACE_STD 
#ifdef __USE_LARGEFILE64 
extern FILE *fopen64 (__const char *__restrict __filename, 
		      __const char *__restrict __modes); 
extern FILE *freopen64 (__const char *__restrict __filename, 
			__const char *__restrict __modes, 
			FILE *__restrict __stream); 
#endif 
 
#ifdef	__USE_POSIX 


extern FILE *fopencookie (void *__restrict __magic_cookie, 
			  __const char *__restrict __modes, 
			  _IO_cookie_io_functions_t __io_funcs) __THROW; 
 


extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __THROW; 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __THROW; 


extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf, 
		    int __modes, size_t __n) __THROW; 
__END_NAMESPACE_STD 
 
#ifdef	__USE_BSD 


extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf, 
		       size_t __size) __THROW; 
 


extern int fprintf (FILE *__restrict __stream, 
		    __const char *__restrict __format, ...); 


extern int printf (__const char *__restrict __format, ...); 


extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format, 
		     _G_va_list __arg); 


extern int vprintf (__const char *__restrict __format, _G_va_list __arg); 


extern int snprintf (char *__restrict __s, size_t __maxlen, 
		     __const char *__restrict __format, ...) 
     __THROW __attribute__ ((__format__ (__printf__, 3, 4))); 
 
extern int vsnprintf (char *__restrict __s, size_t __maxlen, 
		      __const char *__restrict __format, _G_va_list __arg) 
     __THROW __attribute__ ((__format__ (__printf__, 3, 0))); 
__END_NAMESPACE_C99 
#endif 
 
#ifdef __USE_GNU 


extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f, 
		      _G_va_list __arg) 
     __THROW __attribute__ ((__format__ (__printf__, 2, 0))); 
extern int __asprintf (char **__restrict __ptr, 
		       __const char *__restrict __fmt, ...) 
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))); 
extern int asprintf (char **__restrict __ptr, 
		     __const char *__restrict __fmt, ...) 
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))); 
 


extern int vdprintf (int __fd, __const char *__restrict __fmt, 
		     _G_va_list __arg) 
     __attribute__ ((__format__ (__printf__, 2, 0))); 
extern int dprintf (int __fd, __const char *__restrict __fmt, ...) 
     __attribute__ ((__format__ (__printf__, 2, 3))); 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern int fscanf (FILE *__restrict __stream, 
		   __const char *__restrict __format, ...) __wur; 


extern int scanf (__const char *__restrict __format, ...) __wur; 


extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format, 
		    _G_va_list __arg) 
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur; 
 


extern int vscanf (__const char *__restrict __format, _G_va_list __arg) 
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur; 
 


 
 
__BEGIN_NAMESPACE_STD 


extern int fgetc (FILE *__stream); 
extern int getc (FILE *__stream); 
 


extern int getchar (void); 
__END_NAMESPACE_STD 
 


 
#if defined __USE_POSIX || defined __USE_MISC 


extern int getc_unlocked (FILE *__stream); 
extern int getchar_unlocked (void); 
#endif 

extern int fgetc_unlocked (FILE *__stream); 
#endif 

extern int fputc (int __c, FILE *__stream); 
extern int putc (int __c, FILE *__stream); 
 


extern int putchar (int __c); 
__END_NAMESPACE_STD 
 


 
#ifdef __USE_MISC 


extern int fputc_unlocked (int __c, FILE *__stream); 
#endif 

extern int putc_unlocked (int __c, FILE *__stream); 
extern int putchar_unlocked (int __c); 
#endif 

extern int getw (FILE *__stream); 
 


extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream) 
     __wur; 
 


extern char *gets (char *__s) __wur; 
__END_NAMESPACE_STD 
 
#ifdef __USE_GNU 


extern char *fgets_unlocked (char *__restrict __s, int __n, 
			     FILE *__restrict __stream) __wur; 
#endif 
 
 
#ifdef	__USE_GNU 


extern _IO_ssize_t __getdelim (char **__restrict __lineptr, 
			       size_t *__restrict __n, int __delimiter, 
			       FILE *__restrict __stream) __wur; 
extern _IO_ssize_t getdelim (char **__restrict __lineptr, 
			     size_t *__restrict __n, int __delimiter, 
			     FILE *__restrict __stream) __wur; 
 


extern _IO_ssize_t getline (char **__restrict __lineptr, 
			    size_t *__restrict __n, 
			    FILE *__restrict __stream) __wur; 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern int fputs (__const char *__restrict __s, FILE *__restrict __stream); 
 


extern int puts (__const char *__s); 
 
 


extern int ungetc (int __c, FILE *__stream); 
 
 


extern size_t fread (void *__restrict __ptr, size_t __size, 
		     size_t __n, FILE *__restrict __stream) __wur; 


extern size_t fwrite (__const void *__restrict __ptr, size_t __size, 
		      size_t __n, FILE *__restrict __s) __wur; 
__END_NAMESPACE_STD 
 
#ifdef __USE_GNU 


extern int fputs_unlocked (__const char *__restrict __s, 
			   FILE *__restrict __stream); 
#endif 
 
#ifdef __USE_MISC 


extern size_t fread_unlocked (void *__restrict __ptr, size_t __size, 
			      size_t __n, FILE *__restrict __stream) __wur; 
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size, 
			       size_t __n, FILE *__restrict __stream) __wur; 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern int fseek (FILE *__stream, long int __off, int __whence); 


extern long int ftell (FILE *__stream) __wur; 


extern void rewind (FILE *__stream); 
__END_NAMESPACE_STD 
 


 
#if defined __USE_LARGEFILE || defined __USE_XOPEN2K 
# ifndef __USE_FILE_OFFSET64 


extern int fseeko (FILE *__stream, __off_t __off, int __whence); 


extern __off_t ftello (FILE *__stream) __wur; 
# else 
#  ifdef __REDIRECT 
extern int __REDIRECT (fseeko, 
		       (FILE *__stream, __off64_t __off, int __whence), 
		       fseeko64); 
extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64); 
#  else 
#   define fseeko fseeko64 
#   define ftello ftello64 
#  endif 
# endif 
#endif 
 
__BEGIN_NAMESPACE_STD 
#ifndef __USE_FILE_OFFSET64 


extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos); 


extern int fsetpos (FILE *__stream, __const fpos_t *__pos); 
#else 
# ifdef __REDIRECT 
extern int __REDIRECT (fgetpos, (FILE *__restrict __stream, 
				 fpos_t *__restrict __pos), fgetpos64); 
extern int __REDIRECT (fsetpos, 
		       (FILE *__stream, __const fpos_t *__pos), fsetpos64); 
# else 
#  define fgetpos fgetpos64 
#  define fsetpos fsetpos64 
# endif 
#endif 
__END_NAMESPACE_STD 
 
#ifdef __USE_LARGEFILE64 
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence); 
extern __off64_t ftello64 (FILE *__stream) __wur; 
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos); 
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos); 
#endif 
 
__BEGIN_NAMESPACE_STD 


extern int feof (FILE *__stream) __THROW __wur; 


extern void clearerr_unlocked (FILE *__stream) __THROW; 
extern int feof_unlocked (FILE *__stream) __THROW __wur; 
extern int ferror_unlocked (FILE *__stream) __THROW __wur; 
#endif 
 
 
__BEGIN_NAMESPACE_STD 


extern void perror (__const char *__s); 
__END_NAMESPACE_STD 
 




 
#ifndef _STDIO_H 
# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead." 
#endif 
 

 
 
#ifdef	__USE_POSIX 


 
#ifdef __USE_MISC 


extern FILE *popen (__const char *__command, __const char *__modes) __wur; 
 


extern int pclose (FILE *__stream); 
#endif 
 
 
#ifdef	__USE_POSIX 


 
 
#ifdef __USE_XOPEN 


 
 
#ifdef	__USE_GNU 
struct obstack;			

extern int obstack_printf (struct obstack *__restrict __obstack, 
			   __const char *__restrict __format, ...) 
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))); 
extern int obstack_vprintf (struct obstack *__restrict __obstack, 
			    __const char *__restrict __format, 
			    _G_va_list __args) 
     __THROW __attribute__ ((__format__ (__printf__, 2, 0))); 
#endif 

 


extern int ftrylockfile (FILE *__stream) __THROW __wur; 
 


 
#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU 


# define __need_getopt 
# include <getopt.h> 
#endif	

#ifdef __USE_EXTERN_INLINES 
# include <bits/stdio.h> 
#endif 
#if __USE_FORTIFY_LEVEL > 0 && !defined __cplusplus 
# include <bits/stdio2.h> 
#endif 
#ifdef __LDBL_COMPAT 
# include <bits/stdio-ldbl.h> 
#endif 
 
__END_DECLS 
 
#endif 

 
 
namespace std { 
  using ::FILE; 
  using ::fpos_t; 
  using ::size_t; 
  using ::clearerr; 
  using ::fgets; 
  using ::fscanf; 
  using ::gets; 
  using ::rename; 
  using ::tmpfile; 
  using ::fclose; 
  using ::fopen; 
  using ::fseek; 
  using ::perror; 
  using ::rewind; 
  using ::tmpnam; 
  using ::feof; 
  using ::fprintf; 
  using ::fsetpos; 
  using ::printf; 
  using ::scanf; 
  using ::ungetc; 
  using ::ferror; 
  using ::fputc; 
  using ::ftell; 
  using ::putc; 
  using ::setbuf; 
  using ::vfprintf; 
  using ::fflush; 
  using ::fputs; 
  using ::fwrite; 
  using ::putchar; 
  using ::setvbuf; 
  using ::vprintf; 
  using ::fgetc; 
  using ::fread; 
  using ::getc; 
  using ::puts; 
  using ::sprintf; 
  using ::vsprintf; 
  using ::fgetpos; 
  using ::freopen; 
  using ::getchar; 
  using ::remove; 
  using ::sscanf; 
} 
 
#endif  
 
#ifndef __CSTDDEF_HEADER 
 
 
namespace std { 
  using ::ptrdiff_t; 
  using ::size_t; 
} 
 
#endif  




 


 
#ifndef _GLIBCXX_GCC_GTHR_H 
 
#ifndef _GLIBCXX_HIDE_EXPORTS 
#pragma GCC visibility push(default) 
#endif 
 


 


#elif defined(_GLIBCXX_HAVE_GTHR_DEFAULT) 
#if __GXX_WEAK__ 
#ifndef _GLIBCXX_GTHREAD_USE_WEAK 
#endif 
#endif 




 


 
#ifndef _GLIBCXX_GCC_GTHR_POSIX_H 
 


 
 


 
#if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER) 
#elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) 
#else 
#endif 
 
#if __GXX_WEAK__ && 1 
# ifndef __gthrw_pragma 
#  define __gthrw_pragma(pragma) 
# endif 
# define __gthrw2(name,name2,type) \ 
  extern __typeof(type) name __attribute__ ((__weakref__(#name2))); \ 
  __gthrw_pragma(weak type) 
# define __gthrw_(name) __gthrw_ ## name 
#else 
# define __gthrw2(name,name2,type) 
# define __gthrw_(name) name 
#endif 
 


#if defined(__osf__) && defined(_PTHREAD_USE_MANGLED_NAMES_) 
__gthrw3(pthread_once) 
__gthrw3(pthread_getspecific) 
__gthrw3(pthread_setspecific) 
__gthrw3(pthread_create) 
__gthrw3(pthread_cancel) 
__gthrw3(pthread_mutex_lock) 
__gthrw3(pthread_mutex_trylock) 
__gthrw3(pthread_mutex_unlock) 
__gthrw3(pthread_mutex_init) 
__gthrw3(pthread_cond_broadcast) 
__gthrw3(pthread_cond_wait) 
#else 
__gthrw(pthread_once) 
__gthrw(pthread_getspecific) 
__gthrw(pthread_setspecific) 
__gthrw(pthread_create) 
__gthrw(pthread_cancel) 
__gthrw(pthread_mutex_lock) 
__gthrw(pthread_mutex_trylock) 
__gthrw(pthread_mutex_unlock) 
__gthrw(pthread_mutex_init) 
__gthrw(pthread_cond_broadcast) 
__gthrw(pthread_cond_wait) 
#endif 
 
__gthrw(pthread_key_create) 
__gthrw(pthread_key_delete) 
__gthrw(pthread_mutexattr_init) 
__gthrw(pthread_mutexattr_settype) 
__gthrw(pthread_mutexattr_destroy) 
 
 
#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK) 


#ifdef _POSIX_PRIORITY_SCHEDULING 
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING 
__gthrw(sched_get_priority_max) 
__gthrw(sched_get_priority_min) 
#endif 

__gthrw(sched_yield) 
__gthrw(pthread_attr_destroy) 
__gthrw(pthread_attr_init) 
__gthrw(pthread_attr_setdetachstate) 
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING 
__gthrw(pthread_getschedparam) 
__gthrw(pthread_setschedparam) 
#endif 

 
#if __GXX_WEAK__ && 1 
 
static inline int 
__gthread_active_p (void) 
{ 
  static void *const __gthread_active_ptr  
    = __extension__ (void *) &__gthrw_(pthread_cancel); 
  return __gthread_active_ptr != 0; 
} 
 
#else 

 
#ifdef _LIBOBJC 
 


static pthread_key_t _objc_thread_storage; 
static pthread_attr_t _objc_thread_attribs; 
 


 


      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0) 
	{ 
	  

	  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0 
	      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs, 
					      PTHREAD_CREATE_DETACHED) == 0) 
	    return 0; 
	} 
    } 
 
  return -1; 
} 
 


 


static inline int 
__gthread_objc_thread_set_priority (int priority) 
{ 
  if (!__gthread_active_p ()) 
    return -1; 
  else 
    { 
#ifdef _POSIX_PRIORITY_SCHEDULING 
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING 
      pthread_t thread_id = __gthrw_(pthread_self) (); 
      int policy; 
      struct sched_param params; 
      int priority_min, priority_max; 
 
      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0) 
	{ 
	  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1) 
	    return -1; 
 
	  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1) 
	    return -1; 
 
	  if (priority > priority_max) 
	    priority = priority_max; 
	  else if (priority < priority_min) 
	    priority = priority_min; 
	  params.sched_priority = priority; 
 
	  

	  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0) 
	    return 0; 
	} 
#endif 

      return -1; 
    } 
} 
 


#endif 

static inline void 
__gthread_objc_thread_yield (void) 
{ 
  if (__gthread_active_p ()) 
    __gthrw_(sched_yield) (); 
} 
 


    __gthrw_(pthread_exit) (&__objc_thread_exit_status); 
 
  

static inline objc_thread_t 
__gthread_objc_thread_id (void) 
{ 
  if (__gthread_active_p ()) 
    return (objc_thread_t) __gthrw_(pthread_self) (); 
  else 
    return (objc_thread_t) 1; 
} 
 


static inline void * 
__gthread_objc_thread_get_data (void) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_getspecific) (_objc_thread_storage); 
  else 
    return thread_local_storage; 
} 
 


static inline int 
__gthread_objc_mutex_allocate (objc_mutex_t mutex) 
{ 
  if (__gthread_active_p ()) 
    { 
      mutex->backend = objc_malloc (sizeof (pthread_mutex_t)); 
 
      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL)) 
	{ 
	  objc_free (mutex->backend); 
	  mutex->backend = NULL; 
	  return -1; 
	} 
    } 
 
  return 0; 
} 
 


 
      do 
	{ 
	  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend); 
	  if (count < 0) 
	    return -1; 
	} 
      while (count); 
 
      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend)) 
	return -1; 
 
      objc_free (mutex->backend); 
      mutex->backend = NULL; 
    } 
  return 0; 
} 
 


static inline int 
__gthread_objc_mutex_trylock (objc_mutex_t mutex) 
{ 
  if (__gthread_active_p () 
      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0) 
    { 
      return -1; 
    } 
 
  return 0; 
} 
 


 


static inline int 
__gthread_objc_condition_deallocate (objc_condition_t condition) 
{ 
  if (__gthread_active_p ()) 
    { 
      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend)) 
	return -1; 
 
      objc_free (condition->backend); 
      condition->backend = NULL; 
    } 
  return 0; 
} 
 


static inline int 
__gthread_objc_condition_broadcast (objc_condition_t condition) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend); 
  else 
    return 0; 
} 
 


 
static inline int 
__gthread_once (__gthread_once_t *once, void (*func) (void)) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_once) (once, func); 
  else 
    return -1; 
} 
 
static inline int 
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *)) 
{ 
  return __gthrw_(pthread_key_create) (key, dtor); 
} 
 
static inline int 
__gthread_key_delete (__gthread_key_t key) 
{ 
  return __gthrw_(pthread_key_delete) (key); 
} 
 
static inline void * 
__gthread_getspecific (__gthread_key_t key) 
{ 
  return __gthrw_(pthread_getspecific) (key); 
} 
 
static inline int 
__gthread_setspecific (__gthread_key_t key, const void *ptr) 
{ 
  return __gthrw_(pthread_setspecific) (key, ptr); 
} 
 
static inline int 
__gthread_mutex_lock (__gthread_mutex_t *mutex) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_mutex_lock) (mutex); 
  else 
    return 0; 
} 
 
static inline int 
__gthread_mutex_trylock (__gthread_mutex_t *mutex) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_mutex_trylock) (mutex); 
  else 
    return 0; 
} 
 
static inline int 
__gthread_mutex_unlock (__gthread_mutex_t *mutex) 
{ 
  if (__gthread_active_p ()) 
    return __gthrw_(pthread_mutex_unlock) (mutex); 
  else 
    return 0; 
} 
 
#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP 
static inline int 
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex) 
{ 
  if (__gthread_active_p ()) 
    { 
      pthread_mutexattr_t attr; 
      int r; 
 
      r = __gthrw_(pthread_mutexattr_init) (&attr); 
      if (!r) 
	r = __gthrw_(pthread_mutexattr_settype) (&attr, PTHREAD_MUTEX_RECURSIVE); 
      if (!r) 
	r = __gthrw_(pthread_mutex_init) (mutex, &attr); 
      if (!r) 
	r = __gthrw_(pthread_mutexattr_destroy) (&attr); 
      return r; 
    } 
  return 0; 
} 
#endif 
 
static inline int 
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex) 
{ 
  return __gthread_mutex_lock (mutex); 
} 
 
static inline int 
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex) 
{ 
  return __gthread_mutex_trylock (mutex); 
} 
 
static inline int 
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex) 
{ 
  return __gthread_mutex_unlock (mutex); 
} 
 
static inline int 
__gthread_cond_broadcast (__gthread_cond_t *cond) 
{ 
  return __gthrw_(pthread_cond_broadcast) (cond); 
} 
 
static inline int 
__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex) 
{ 
  return __gthrw_(pthread_cond_wait) (cond, mutex); 
} 
 
static inline int 
__gthread_cond_wait_recursive (__gthread_cond_t *cond, 
			       __gthread_recursive_mutex_t *mutex) 
{ 
  return __gthread_cond_wait (cond, mutex); 
} 
 
#endif 

 
 


 
 
namespace std  
{ 
  typedef __gthread_mutex_t __c_lock; 
 
    typedef FILE __c_file; 
} 
 
#endif 
 
#include <cctype>		#include <bits/stringfwd.h> 	 
 
 
 
 
 


 
#ifndef _GLIBCXX_POSTYPES_H 
 
#pragma GCC system_header 
 
#include <cwchar>  
#ifdef 1 
#include <stdint.h> #endif 
 
namespace std 
{ 
             
  
  
#ifdef _GLIBCXX_HAVE_INT64_T 
  typedef int64_t       streamoff; 
#else 
  typedef long long     streamoff; 
#endif 
 
    typedef ptrdiff_t	streamsize;  
  template<typename _StateT> 
    class fpos; 
 
  

  template<typename _StateT> 
    class fpos 
    { 
    private: 
      streamoff	                _M_off; 
      _StateT			_M_state; 
 
    public: 
                              fpos() 
      : _M_off(0), _M_state() { } 
 
                                                fpos(streamoff __off) 
      : _M_off(__off), _M_state() { } 
 
            operator streamoff() const { return _M_off; } 
 
            void 
      state(_StateT __st) 
      { _M_state = __st; } 
 
            _StateT 
      state() const 
      { return _M_state; } 
 
                                    bool 
      operator==(const fpos& __other) const 
      { return _M_off == __other._M_off; } 
 
            bool 
      operator!=(const fpos& __other) const 
      { return _M_off != __other._M_off; } 
 
                              fpos& 
      operator+=(streamoff __off) 
      { 
	_M_off += __off; 
	return *this; 
      } 
 
                              fpos& 
      operator-=(streamoff __off) 
      { 
	_M_off -= __off; 
	return *this; 
      } 
 
                                          fpos 
      operator+(streamoff __off) const 
      { 
	fpos __pos(*this); 
	__pos += __off; 
	return __pos; 
      } 
 
                                          fpos 
      operator-(streamoff __off) const 
      { 
	fpos __pos(*this); 
	__pos -= __off; 
	return __pos; 
      } 
 
                                    streamoff 
      operator-(const fpos& __other) const 
      { return _M_off - __other._M_off; } 
    }; 
 
          typedef fpos<mbstate_t> streampos; 
    typedef fpos<mbstate_t> wstreampos; 
}  
#endif 
 
 
 
 
 
 


 
 
#ifndef _FUNCTEXCEPT_H 
 
 
 
 
 
 
 
#ifndef _EXCEPTION_DEFINES_H 
 
#ifndef __EXCEPTIONS 
# define try      if (true) 
# define catch(X) if (false) 
# define __throw_exception_again 
#else 
# define __throw_exception_again throw 
#endif 
 
#endif 
 
 
namespace std 
{ 
    void 
  __throw_bad_exception(void) __attribute__((__noreturn__)); 
 
    void 
  __throw_bad_alloc(void) __attribute__((__noreturn__)); 
 
    void 
  __throw_bad_cast(void) __attribute__((__noreturn__)); 
 
  void 
  __throw_bad_typeid(void) __attribute__((__noreturn__)); 
 
    void 
  __throw_logic_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_domain_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_invalid_argument(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_length_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_out_of_range(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_runtime_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_range_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_overflow_error(const char*) __attribute__((__noreturn__)); 
 
  void 
  __throw_underflow_error(const char*) __attribute__((__noreturn__)); 
 
    void 
  __throw_ios_failure(const char*) __attribute__((__noreturn__)); 
}  
#endif 
 
 
namespace std  
{ 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_ios; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_streambuf; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_istream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_ostream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_iostream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT>, 
	    typename _Alloc = allocator<_CharT> > 
    class basic_stringbuf; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT>, 
	   typename _Alloc = allocator<_CharT> > 
    class basic_istringstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT>, 
	   typename _Alloc = allocator<_CharT> > 
    class basic_ostringstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT>, 
	   typename _Alloc = allocator<_CharT> > 
    class basic_stringstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_filebuf; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_ifstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_ofstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class basic_fstream; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class istreambuf_iterator; 
 
  template<typename _CharT, typename _Traits = char_traits<_CharT> > 
    class ostreambuf_iterator; 
 
      class ios_base;  
 
  

  typedef basic_ios<char> 		ios;		  typedef basic_streambuf<char> 	streambuf;	  typedef basic_istream<char> 		istream;	  typedef basic_ostream<char> 		ostream;	  typedef basic_iostream<char> 		iostream;	  typedef basic_stringbuf<char> 	stringbuf;	  typedef basic_istringstream<char> 	istringstream;	  typedef basic_ostringstream<char> 	ostringstream;	  typedef basic_stringstream<char> 	stringstream;	  typedef basic_filebuf<char> 		filebuf;	  typedef basic_ifstream<char> 		ifstream;	  typedef basic_ofstream<char> 		ofstream;	  typedef basic_fstream<char> 		fstream;	 
#ifdef _GLIBCXX_USE_WCHAR_T 
  typedef basic_ios<wchar_t> 		wios;		  typedef basic_streambuf<wchar_t> 	wstreambuf;	  typedef basic_istream<wchar_t> 	wistream;	  typedef basic_ostream<wchar_t> 	wostream;	  typedef basic_iostream<wchar_t> 	wiostream;	  typedef basic_stringbuf<wchar_t> 	wstringbuf;	  typedef basic_istringstream<wchar_t> 	wistringstream;	  typedef basic_ostringstream<wchar_t> 	wostringstream;	  typedef basic_stringstream<wchar_t> 	wstringstream;	  typedef basic_filebuf<wchar_t> 	wfilebuf;	  typedef basic_ifstream<wchar_t> 	wifstream;	  typedef basic_ofstream<wchar_t> 	wofstream;	  typedef basic_fstream<wchar_t> 	wfstream;	#endif 
  

 
#include <exception> 		#include <bits/char_traits.h> 	#include <cstdio> 	#include <bits/localefwd.h>	#include <bits/ios_base.h>	 
 
 
 
 
 


 
#ifndef _BASIC_IOS_H 
 
#pragma GCC system_header 
 
 
 
 
 
 


 
#ifndef _STREAMBUF_ITERATOR_H 
 
#pragma GCC system_header 
 
#ifndef _SEPOL_DEBUG_H_ 
 
#ifndef _SEPOL_HANDLE_H_ 
 
struct sepol_handle; 
typedef struct sepol_handle sepol_handle_t; 
 


void sepol_set_disable_dontaudit(sepol_handle_t * sh, int disable_dontaudit); 
 

 


 
 
extern int sepol_msg_get_level(sepol_handle_t * handle); 
 
extern const char *sepol_msg_get_channel(sepol_handle_t * handle); 
 
extern const char *sepol_msg_get_fname(sepol_handle_t * handle); 
 


extern void sepol_msg_set_callback(sepol_handle_t * handle, 
#ifdef __GNUC__ 
				   __attribute__ ((format(printf, 3, 4))) 
#endif 
				   void (*msg_callback) (void *varg, 
							 sepol_handle_t * 
							 handle, 
							 const char *fmt, ...), 
				   void *msg_callback_arg); 
#endif 
 
 
 
namespace std 
{ 
      template<typename _CharT, typename _Traits> 
    class istreambuf_iterator 
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type, 
		      _CharT*, _CharT&> 
    { 
    public: 
                        typedef _CharT					char_type; 
      typedef _Traits					traits_type; 
      typedef typename _Traits::int_type		int_type; 
      typedef basic_streambuf<_CharT, _Traits>		streambuf_type; 
      typedef basic_istream<_CharT, _Traits>		istream_type; 
       
    private: 
                                                mutable streambuf_type*	_M_sbuf; 
      mutable int_type		_M_c; 
 
    public: 
            istreambuf_iterator() throw() 
      : _M_sbuf(0), _M_c(traits_type::eof()) { } 
 
            istreambuf_iterator(istream_type& __s) throw() 
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { } 
 
            istreambuf_iterator(streambuf_type* __s) throw() 
      : _M_sbuf(__s), _M_c(traits_type::eof()) { } 
 
                        char_type 
      operator*() const 
      { 
#ifdef _GLIBCXX_DEBUG_PEDANTIC 
			__glibcxx_requires_cond(!_M_at_eof(), 
				_M_message(__gnu_debug::__msg_deref_istreambuf) 
				._M_iterator(*this)); 
#endif 
	return traits_type::to_char_type(_M_get()); 
      } 
 
            istreambuf_iterator& 
      operator++() 
      { 
	__glibcxx_requires_cond(!_M_at_eof(), 
				_M_message(__gnu_debug::__msg_inc_istreambuf) 
				._M_iterator(*this)); 
	if (_M_sbuf) 
	  { 
	    _M_sbuf->sbumpc(); 
	    _M_c = traits_type::eof(); 
	  } 
	return *this; 
      } 
 
            istreambuf_iterator 
      operator++(int) 
      { 
	__glibcxx_requires_cond(!_M_at_eof(), 
				_M_message(__gnu_debug::__msg_inc_istreambuf) 
				._M_iterator(*this)); 
 
	istreambuf_iterator __old = *this; 
	if (_M_sbuf) 
	  { 
	    __old._M_c = _M_sbuf->sbumpc(); 
	    _M_c = traits_type::eof(); 
	  } 
	return __old; 
      } 
 
                              bool 
      equal(const istreambuf_iterator& __b) const 
      { 
	const bool __thiseof = _M_at_eof(); 
	const bool __beof = __b._M_at_eof(); 
	return (__thiseof && __beof || (!__thiseof && !__beof)); 
      } 
 
    private: 
      int_type 
      _M_get() const 
      { 
	const int_type __eof = traits_type::eof(); 
	int_type __ret = __eof; 
	if (_M_sbuf) 
	  { 
	    if (!traits_type::eq_int_type(_M_c, __eof)) 
	      __ret = _M_c; 
	    else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), 
					       __eof)) 
	      _M_c = __ret; 
	    else 
	      _M_sbuf = 0; 
	  } 
	return __ret; 
      } 
 
      bool 
      _M_at_eof() const 
      { 
	const int_type __eof = traits_type::eof(); 
	return traits_type::eq_int_type(_M_get(), __eof); 
      } 
    }; 
 
  template<typename _CharT, typename _Traits> 
    inline bool 
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a, 
	       const istreambuf_iterator<_CharT, _Traits>& __b) 
    { return __a.equal(__b); } 
 
  template<typename _CharT, typename _Traits> 
    inline bool 
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a, 
	       const istreambuf_iterator<_CharT, _Traits>& __b) 
    { return !__a.equal(__b); } 
 
    template<typename _CharT, typename _Traits> 
    class ostreambuf_iterator 
    : public iterator<output_iterator_tag, void, void, void, void> 
    { 
    public: 
                        typedef _CharT                           char_type; 
      typedef _Traits                          traits_type; 
      typedef basic_streambuf<_CharT, _Traits> streambuf_type; 
      typedef basic_ostream<_CharT, _Traits>   ostream_type; 
       
    private: 
      streambuf_type*	_M_sbuf; 
      bool		_M_failed; 
 
    public: 
            ostreambuf_iterator(ostream_type& __s) throw () 
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { } 
 
            ostreambuf_iterator(streambuf_type* __s) throw () 
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { } 
 
            ostreambuf_iterator& 
      operator=(_CharT __c) 
      { 
	if (!_M_failed && 
	    _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof())) 
	  _M_failed = true; 
	return *this; 
      } 
 
            ostreambuf_iterator& 
      operator*() 
      { return *this; } 
 
            ostreambuf_iterator& 
      operator++(int) 
      { return *this; } 
 
            ostreambuf_iterator& 
      operator++() 
      { return *this; } 
 
            bool 
      failed() const throw() 
      { return _M_failed; } 
 
      ostreambuf_iterator& 
      _M_put(const _CharT* __ws, streamsize __len) 
      { 
	if (__builtin_expect(!_M_failed, true) 
	    && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, 
				false)) 
	  _M_failed = true; 
	return *this; 
      } 
    }; 
} #endif 
 
 
 
 
 
 
 


 
#ifndef _LOCALE_FWD_H 
 
#pragma GCC system_header 
 
#include <bits/c++locale.h>     #include <iosfwd>		 
namespace std 
{ 
    class locale; 
 
    template<typename _CharT> 
    inline bool 
    isspace(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isprint(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    iscntrl(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isupper(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    islower(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isalpha(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isdigit(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    ispunct(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isxdigit(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isalnum(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline bool 
    isgraph(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline _CharT 
    toupper(_CharT, const locale&); 
 
  template<typename _CharT> 
    inline _CharT 
    tolower(_CharT, const locale&); 
 
    class ctype_base; 
  template<typename _CharT> 
    class ctype; 
  template<> class ctype<char>; 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> class ctype<wchar_t>; 
#endif 
  template<typename _CharT> 
    class ctype_byname; 
   
  class codecvt_base; 
  class __enc_traits; 
  template<typename _InternT, typename _ExternT, typename _StateT> 
    class codecvt; 
  template<> class codecvt<char, char, mbstate_t>; 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> class codecvt<wchar_t, char, mbstate_t>; 
#endif 
  template<typename _InternT, typename _ExternT, typename _StateT> 
    class codecvt_byname; 
 
  _GLIBCXX_BEGIN_LDBL_NAMESPACE 
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> > 
    class num_get; 
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> > 
    class num_put; 
_GLIBCXX_END_LDBL_NAMESPACE 
  template<typename _CharT> class numpunct; 
  template<typename _CharT> class numpunct_byname; 
 
    template<typename _CharT> 
    class collate; 
  template<typename _CharT> class 
    collate_byname; 
 
    class time_base; 
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> > 
    class time_get; 
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> > 
    class time_get_byname; 
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> > 
    class time_put; 
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> > 
    class time_put_byname; 
 
    class money_base; 
_GLIBCXX_BEGIN_LDBL_NAMESPACE 
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> > 
    class money_get; 
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> > 
    class money_put; 
_GLIBCXX_END_LDBL_NAMESPACE 
  template<typename _CharT, bool _Intl = false> 
    class moneypunct; 
  template<typename _CharT, bool _Intl = false> 
    class moneypunct_byname; 
 
    class messages_base; 
  template<typename _CharT> 
    class messages; 
  template<typename _CharT> 
    class messages_byname; 
 
  template<typename _Facet> 
    bool 
    has_facet(const locale& __loc) throw(); 
 
  template<typename _Facet> 
    const _Facet& 
    use_facet(const locale& __loc); 
 
  template<typename _Facet> 
    inline const _Facet& 
    __check_facet(const _Facet* __f) 
    { 
      if (!__f) 
	__throw_bad_cast(); 
      return *__f; 
    } 
}  
#endif 
 
 
 
 
 
 
 


 
#ifndef _LOCALE_CLASSES_H 
 
#pragma GCC system_header 
 
#include <cstring>		 
 
 
 
 
 


 
#ifndef _GLIBCXX_ATOMICITY_H 
 
 
 
 
 
 
#ifndef _GLIBCXX_ATOMIC_WORD_H 
 
typedef int _Atomic_word; 
 
 
 
 
#endif  
 
   
namespace __gnu_cxx 
{ 
  _Atomic_word  
  __attribute__ ((__unused__)) 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val); 
 
  void 
  __attribute__ ((__unused__)) 
  __atomic_add(volatile _Atomic_word* __mem, int __val); 
}  


#ifndef _GLIBCXX_READ_MEM_BARRIER 
#endif 
#ifndef _GLIBCXX_WRITE_MEM_BARRIER 
#endif 
 
#endif  
 
 
namespace std 
{ 
    

  class locale 
  { 
  public: 
            typedef int	category; 
 
        class facet; 
    class id; 
    class _Impl; 
 
    friend class facet; 
    friend class _Impl; 
 
    template<typename _Facet> 
      friend bool 
      has_facet(const locale&) throw(); 
 
    template<typename _Facet> 
      friend const _Facet& 
      use_facet(const locale&); 
 
    template<typename _Cache> 
      friend struct __use_cache; 
 
        

    static const category none		= 0; 
    static const category ctype		= 1L << 0; 
    static const category numeric	= 1L << 1; 
    static const category collate	= 1L << 2; 
    static const category time		= 1L << 3; 
    static const category monetary	= 1L << 4; 
    static const category messages	= 1L << 5; 
    static const category all		= (ctype | numeric | collate | 
					   time  | monetary | messages); 
     
     
    

    locale() throw(); 
 
    

    locale(const locale& __other) throw(); 
 
    

    explicit 
    locale(const char* __s); 
 
    

    locale(const locale& __base, const char* __s, category __cat); 
 
    

    locale(const locale& __base, const locale& __add, category __cat); 
 
    

    template<typename _Facet> 
      locale(const locale& __other, _Facet* __f); 
 
        ~locale() throw(); 
 
    

    const locale& 
    operator=(const locale& __other) throw(); 
 
    

    template<typename _Facet> 
      locale 
      combine(const locale& __other) const; 
 
        

    string 
    name() const; 
 
    

    bool 
    operator==(const locale& __other) const throw (); 
 
    

    inline bool 
    operator!=(const locale& __other) const throw () 
    { return !(this->operator==(__other));  } 
 
    

    template<typename _Char, typename _Traits, typename _Alloc> 
      bool 
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1, 
		 const basic_string<_Char, _Traits, _Alloc>& __s2) const; 
 
        

    static locale 
    global(const locale&); 
 
    

    static const locale& 
    classic(); 
 
  private: 
        _Impl*		_M_impl; 
 
        static _Impl*       _S_classic; 
 
        static _Impl*	_S_global; 
 
                    static const char* const* const _S_categories; 
 
                                            enum { _S_categories_size = 6 + 6 }; 
 
#ifdef 1 
    static __gthread_once_t _S_once; 
#endif 
 
    explicit 
    locale(_Impl*) throw(); 
 
    static void 
    _S_initialize(); 
 
    static void 
    _S_initialize_once(); 
 
    static category 
    _S_normalize_category(category); 
 
    void 
    _M_coalesce(const locale& __base, const locale& __add, category __cat); 
  }; 
 
 
    

  class locale::facet 
  { 
  private: 
    friend class locale; 
    friend class locale::_Impl; 
 
    mutable _Atomic_word		_M_refcount; 
 
        static __c_locale                   _S_c_locale; 
 
        static const char			_S_c_name[2]; 
 
#ifdef 1 
    static __gthread_once_t		_S_once; 
#endif 
 
    static void 
    _S_initialize_once(); 
 
  protected: 
    

    explicit 
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0) 
    { } 
 
        virtual 
    ~facet(); 
 
    static void 
    _S_create_c_locale(__c_locale& __cloc, const char* __s, 
		       __c_locale __old = 0); 
 
    static __c_locale 
    _S_clone_c_locale(__c_locale& __cloc); 
 
    static void 
    _S_destroy_c_locale(__c_locale& __cloc); 
 
            static __c_locale 
    _S_get_c_locale(); 
 
    static const char* 
    _S_get_c_name(); 
 
  private: 
    inline void 
    _M_add_reference() const throw() 
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); } 
 
    inline void 
    _M_remove_reference() const throw() 
    { 
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1) 
	{ 
	  try 
	    { delete this; } 
	  catch (...) 
	    { } 
	} 
    } 
 
    facet(const facet&);   
    facet& 
    operator=(const facet&);    }; 
 
 
    

  class locale::id 
  { 
  private: 
    friend class locale; 
    friend class locale::_Impl; 
 
    template<typename _Facet> 
      friend const _Facet& 
      use_facet(const locale&); 
 
    template<typename _Facet> 
      friend bool 
      has_facet(const locale&) throw (); 
 
                mutable size_t		_M_index; 
 
        static _Atomic_word		_S_refcount; 
 
    void 
    operator=(const id&);   
    id(const id&);   
  public: 
                id() { } 
 
    size_t 
    _M_id() const; 
  }; 
 
 
    class locale::_Impl 
  { 
  public: 
        friend class locale; 
    friend class locale::facet; 
 
    template<typename _Facet> 
      friend bool 
      has_facet(const locale&) throw(); 
 
    template<typename _Facet> 
      friend const _Facet& 
      use_facet(const locale&); 
 
    template<typename _Cache> 
      friend struct __use_cache; 
 
  private: 
        _Atomic_word			_M_refcount; 
    const facet**			_M_facets; 
    size_t				_M_facets_size; 
    const facet**			_M_caches; 
    char**				_M_names; 
    static const locale::id* const	_S_id_ctype[]; 
    static const locale::id* const	_S_id_numeric[]; 
    static const locale::id* const	_S_id_collate[]; 
    static const locale::id* const	_S_id_time[]; 
    static const locale::id* const	_S_id_monetary[]; 
    static const locale::id* const	_S_id_messages[]; 
    static const locale::id* const* const _S_facet_categories[]; 
 
    inline void 
    _M_add_reference() throw() 
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); } 
 
    inline void 
    _M_remove_reference() throw() 
    { 
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1) 
	{ 
	  try 
	    { delete this; } 
	  catch(...) 
	    { } 
	} 
    } 
 
    _Impl(const _Impl&, size_t); 
    _Impl(const char*, size_t); 
    _Impl(size_t) throw(); 
 
   ~_Impl() throw(); 
 
    _Impl(const _Impl&);   
    void 
    operator=(const _Impl&);   
    inline bool 
    _M_check_same_name() 
    { 
      bool __ret = true; 
      if (_M_names[1]) 
		for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i) 
	  __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0; 
      return __ret; 
    } 
 
    void 
    _M_replace_categories(const _Impl*, category); 
 
    void 
    _M_replace_category(const _Impl*, const locale::id* const*); 
 
    void 
    _M_replace_facet(const _Impl*, const locale::id*); 
 
    void 
    _M_install_facet(const locale::id*, const facet*); 
 
    template<typename _Facet> 
      inline void 
      _M_init_facet(_Facet* __facet) 
      { _M_install_facet(&_Facet::id, __facet); } 
 
    void 
    _M_install_cache(const facet*, size_t); 
  }; 
 
  template<typename _Facet> 
    locale::locale(const locale& __other, _Facet* __f) 
    { 
      _M_impl = new _Impl(*__other._M_impl, 1); 
 
      try 
	{ _M_impl->_M_install_facet(&_Facet::id, __f); } 
      catch(...) 
	{ 
	  _M_impl->_M_remove_reference(); 
	  __throw_exception_again; 
	} 
      delete [] _M_impl->_M_names[0]; 
      _M_impl->_M_names[0] = 0;       } 
}  
#endif 
 
 
 
 
 
 
 


 
#ifndef _LOCALE_FACETS_H 
 
#pragma GCC system_header 
 
#include <ctime>	#include <cwctype>	#include <bits/ios_base.h>   
namespace std 
{ 
  #ifdef _GLIBCXX_USE_WCHAR_T 
# define  _GLIBCXX_NUM_FACETS 28 
#else 
# define  _GLIBCXX_NUM_FACETS 14 
#endif 
 
        template<typename _Tv> 
    void 
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err, 
		   const __c_locale& __cloc); 
 
    template<> 
    void 
    __convert_to_v(const char*, float&, ios_base::iostate&, 
		   const __c_locale&); 
 
  template<> 
    void 
    __convert_to_v(const char*, double&, ios_base::iostate&, 
		   const __c_locale&); 
 
  template<> 
    void 
    __convert_to_v(const char*, long double&, ios_base::iostate&, 
		   const __c_locale&); 
 
      template<typename _CharT, typename _Traits> 
    struct __pad 
    { 
      static void 
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news, 
	     const _CharT* __olds, const streamsize __newlen, 
	     const streamsize __oldlen, const bool __num); 
    }; 
 
            template<typename _CharT> 
    _CharT* 
    __add_grouping(_CharT* __s, _CharT __sep, 
		   const char* __gbeg, size_t __gsize, 
		   const _CharT* __first, const _CharT* __last); 
 
        template<typename _CharT> 
    inline 
    ostreambuf_iterator<_CharT> 
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len) 
    { 
      __s._M_put(__ws, __len); 
      return __s; 
    } 
 
    template<typename _CharT, typename _OutIter> 
    inline 
    _OutIter 
    __write(_OutIter __s, const _CharT* __ws, int __len) 
    { 
      for (int __j = 0; __j < __len; __j++, ++__s) 
	*__s = __ws[__j]; 
      return __s; 
    } 
 
 
      #include <bits/ctype_base.h> 
 
    

  template<typename _CharT> 
    class __ctype_abstract_base : public locale::facet, public ctype_base 
    { 
    public: 
                  typedef _CharT char_type; 
 
      

      bool 
      is(mask __m, char_type __c) const 
      { return this->do_is(__m, __c); } 
 
      

      const char_type* 
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const 
      { return this->do_is(__lo, __hi, __vec); } 
 
      

      const char_type* 
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const 
      { return this->do_scan_is(__m, __lo, __hi); } 
 
      

      const char_type* 
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const 
      { return this->do_scan_not(__m, __lo, __hi); } 
 
      

      char_type 
      toupper(char_type __c) const 
      { return this->do_toupper(__c); } 
 
      

      const char_type* 
      toupper(char_type *__lo, const char_type* __hi) const 
      { return this->do_toupper(__lo, __hi); } 
 
      

      char_type 
      tolower(char_type __c) const 
      { return this->do_tolower(__c); } 
 
      

      const char_type* 
      tolower(char_type* __lo, const char_type* __hi) const 
      { return this->do_tolower(__lo, __hi); } 
 
      

      char_type 
      widen(char __c) const 
      { return this->do_widen(__c); } 
 
      

      const char* 
      widen(const char* __lo, const char* __hi, char_type* __to) const 
      { return this->do_widen(__lo, __hi, __to); } 
 
      

      char 
      narrow(char_type __c, char __dfault) const 
      { return this->do_narrow(__c, __dfault); } 
 
      

      const char_type* 
      narrow(const char_type* __lo, const char_type* __hi, 
	      char __dfault, char *__to) const 
      { return this->do_narrow(__lo, __hi, __dfault, __to); } 
 
    protected: 
      explicit 
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { } 
 
      virtual 
      ~__ctype_abstract_base() { } 
 
      

      virtual bool 
      do_is(mask __m, char_type __c) const = 0; 
 
      

      virtual const char_type* 
      do_is(const char_type* __lo, const char_type* __hi, 
	    mask* __vec) const = 0; 
 
      

      virtual const char_type* 
      do_scan_is(mask __m, const char_type* __lo, 
		 const char_type* __hi) const = 0; 
 
      

      virtual const char_type* 
      do_scan_not(mask __m, const char_type* __lo, 
		  const char_type* __hi) const = 0; 
 
      

      virtual char_type 
      do_toupper(char_type) const = 0; 
 
      

      virtual const char_type* 
      do_toupper(char_type* __lo, const char_type* __hi) const = 0; 
 
      

      virtual char_type 
      do_tolower(char_type) const = 0; 
 
      

      virtual const char_type* 
      do_tolower(char_type* __lo, const char_type* __hi) const = 0; 
 
      

      virtual char_type 
      do_widen(char) const = 0; 
 
      

      virtual const char* 
      do_widen(const char* __lo, const char* __hi, 
	       char_type* __dest) const = 0; 
 
      

      virtual char 
      do_narrow(char_type, char __dfault) const = 0; 
 
      

      virtual const char_type* 
      do_narrow(const char_type* __lo, const char_type* __hi, 
		char __dfault, char* __dest) const = 0; 
    }; 
 
    

  template<typename _CharT> 
    class ctype : public __ctype_abstract_base<_CharT> 
    { 
    public: 
            typedef _CharT			char_type; 
      typedef typename __ctype_abstract_base<_CharT>::mask mask; 
 
            static locale::id			id; 
 
      explicit 
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { } 
 
   protected: 
      virtual 
      ~ctype(); 
 
      virtual bool 
      do_is(mask __m, char_type __c) const; 
 
      virtual const char_type* 
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const; 
 
      virtual const char_type* 
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const; 
 
      virtual const char_type* 
      do_scan_not(mask __m, const char_type* __lo, 
		  const char_type* __hi) const; 
 
      virtual char_type 
      do_toupper(char_type __c) const; 
 
      virtual const char_type* 
      do_toupper(char_type* __lo, const char_type* __hi) const; 
 
      virtual char_type 
      do_tolower(char_type __c) const; 
 
      virtual const char_type* 
      do_tolower(char_type* __lo, const char_type* __hi) const; 
 
      virtual char_type 
      do_widen(char __c) const; 
 
      virtual const char* 
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const; 
 
      virtual char 
      do_narrow(char_type, char __dfault) const; 
 
      virtual const char_type* 
      do_narrow(const char_type* __lo, const char_type* __hi, 
		char __dfault, char* __dest) const; 
    }; 
 
  template<typename _CharT> 
    locale::id ctype<_CharT>::id; 
 
    

  template<> 
    class ctype<char> : public locale::facet, public ctype_base 
    { 
    public: 
                  typedef char		char_type; 
 
    protected: 
            __c_locale		_M_c_locale_ctype; 
      bool			_M_del; 
      __to_type			_M_toupper; 
      __to_type			_M_tolower; 
      const mask*		_M_table; 
      mutable char		_M_widen_ok; 
      mutable char		_M_widen[1 + static_cast<unsigned char>(-1)]; 
      mutable char		_M_narrow[1 + static_cast<unsigned char>(-1)]; 
      mutable char		_M_narrow_ok;							 
    public: 
            static locale::id        id; 
            static const size_t      table_size = 1 + static_cast<unsigned char>(-1); 
 
      

      explicit 
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0); 
 
      

      explicit 
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false, 
	    size_t __refs = 0); 
 
      

      inline bool 
      is(mask __m, char __c) const; 
 
      

      inline const char* 
      is(const char* __lo, const char* __hi, mask* __vec) const; 
 
      

      inline const char* 
      scan_is(mask __m, const char* __lo, const char* __hi) const; 
 
      

      inline const char* 
      scan_not(mask __m, const char* __lo, const char* __hi) const; 
 
      

      char_type 
      toupper(char_type __c) const 
      { return this->do_toupper(__c); } 
 
      

      const char_type* 
      toupper(char_type *__lo, const char_type* __hi) const 
      { return this->do_toupper(__lo, __hi); } 
 
      

      char_type 
      tolower(char_type __c) const 
      { return this->do_tolower(__c); } 
 
      

      const char_type* 
      tolower(char_type* __lo, const char_type* __hi) const 
      { return this->do_tolower(__lo, __hi); } 
 
      

      char_type 
      widen(char __c) const 
      { 
	if (_M_widen_ok) 
	  return _M_widen[static_cast<unsigned char>(__c)]; 
	this->_M_widen_init(); 
	return this->do_widen(__c); 
      } 
 
      

      const char* 
      widen(const char* __lo, const char* __hi, char_type* __to) const 
      { 
	if (_M_widen_ok == 1) 
	  { 
	    memcpy(__to, __lo, __hi - __lo); 
	    return __hi; 
	  } 
	if (!_M_widen_ok) 
	  _M_widen_init(); 
	return this->do_widen(__lo, __hi, __to); 
      } 
 
      

      char 
      narrow(char_type __c, char __dfault) const 
      { 
	if (_M_narrow[static_cast<unsigned char>(__c)]) 
	  return _M_narrow[static_cast<unsigned char>(__c)]; 
	const char __t = do_narrow(__c, __dfault); 
	if (__t != __dfault) 
	  _M_narrow[static_cast<unsigned char>(__c)] = __t; 
	return __t; 
      } 
 
      

      const char_type* 
      narrow(const char_type* __lo, const char_type* __hi, 
	     char __dfault, char *__to) const 
      { 
	if (__builtin_expect(_M_narrow_ok == 1, true)) 
	  { 
	    memcpy(__to, __lo, __hi - __lo); 
	    return __hi; 
	  } 
	if (!_M_narrow_ok) 
	  _M_narrow_init(); 
	return this->do_narrow(__lo, __hi, __dfault, __to); 
      } 
 
    protected: 
                  const mask* 
      table() const throw() 
      { return _M_table; } 
 
            static const mask* 
      classic_table() throw(); 
 
      

      virtual 
      ~ctype(); 
 
      

      virtual char_type 
      do_toupper(char_type) const; 
 
      

      virtual const char_type* 
      do_toupper(char_type* __lo, const char_type* __hi) const; 
 
      

      virtual char_type 
      do_tolower(char_type) const; 
 
      

      virtual const char_type* 
      do_tolower(char_type* __lo, const char_type* __hi) const; 
 
      

      virtual char_type 
      do_widen(char __c) const 
      { return __c; } 
 
      

      virtual const char* 
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const 
      { 
	memcpy(__dest, __lo, __hi - __lo); 
	return __hi; 
      } 
 
      

      virtual char 
      do_narrow(char_type __c, char) const 
      { return __c; } 
 
      

      virtual const char_type* 
      do_narrow(const char_type* __lo, const char_type* __hi, 
		char, char* __dest) const 
      { 
	memcpy(__dest, __lo, __hi - __lo); 
	return __hi; 
      } 
 
    private: 
 
      void _M_widen_init() const 
      { 
	char __tmp[sizeof(_M_widen)]; 
	for (size_t __i = 0; __i < sizeof(_M_widen); ++__i) 
	  __tmp[__i] = __i; 
	do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen); 
 
	_M_widen_ok = 1; 
		if (memcmp(__tmp, _M_widen, sizeof(_M_widen))) 
	  _M_widen_ok = 2; 
      } 
 
                        void _M_narrow_init() const 
      { 
	char __tmp[sizeof(_M_narrow)]; 
	for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i) 
	  __tmp[__i] = __i; 
	do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow); 
 
	_M_narrow_ok = 1; 
	if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow))) 
	  _M_narrow_ok = 2; 
	else 
	  { 
	    	    	    char __c; 
	    do_narrow(__tmp, __tmp + 1, 1, &__c); 
	    if (__c == 1) 
	      _M_narrow_ok = 2; 
	  } 
      } 
    }; 
 
  template<> 
    const ctype<char>& 
    use_facet<ctype<char> >(const locale& __loc); 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
    

  template<> 
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> 
    { 
    public: 
                  typedef wchar_t		char_type; 
      typedef wctype_t		__wmask_type; 
 
    protected: 
      __c_locale		_M_c_locale_ctype; 
 
            bool                      _M_narrow_ok; 
      char                      _M_narrow[128]; 
      wint_t                    _M_widen[1 + static_cast<unsigned char>(-1)]; 
 
            mask                      _M_bit[16]; 
      __wmask_type              _M_wmask[16]; 
 
    public: 
                  static locale::id		id; 
 
      

      explicit 
      ctype(size_t __refs = 0); 
 
      

      explicit 
      ctype(__c_locale __cloc, size_t __refs = 0); 
 
    protected: 
      __wmask_type 
      _M_convert_to_wmask(const mask __m) const; 
 
            virtual 
      ~ctype(); 
 
      

      virtual bool 
      do_is(mask __m, char_type __c) const; 
 
      

      virtual const char_type* 
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const; 
 
      

      virtual const char_type* 
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const; 
 
      

      virtual const char_type* 
      do_scan_not(mask __m, const char_type* __lo, 
		  const char_type* __hi) const; 
 
      

      virtual char_type 
      do_toupper(char_type) const; 
 
      

      virtual const char_type* 
      do_toupper(char_type* __lo, const char_type* __hi) const; 
 
      

      virtual char_type 
      do_tolower(char_type) const; 
 
      

      virtual const char_type* 
      do_tolower(char_type* __lo, const char_type* __hi) const; 
 
      

      virtual char_type 
      do_widen(char) const; 
 
      

      virtual const char* 
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const; 
 
      

      virtual char 
      do_narrow(char_type, char __dfault) const; 
 
      

      virtual const char_type* 
      do_narrow(const char_type* __lo, const char_type* __hi, 
		char __dfault, char* __dest) const; 
 
            void 
      _M_initialize_ctype(); 
    }; 
 
  template<> 
    const ctype<wchar_t>& 
    use_facet<ctype<wchar_t> >(const locale& __loc); 
#endif  
    #include <bits/ctype_inline.h> 
 
    template<typename _CharT> 
    class ctype_byname : public ctype<_CharT> 
    { 
    public: 
      typedef _CharT		char_type; 
 
      explicit 
      ctype_byname(const char* __s, size_t __refs = 0); 
 
    protected: 
      virtual 
      ~ctype_byname() { }; 
    }; 
 
    template<> 
    ctype_byname<char>::ctype_byname(const char*, size_t refs); 
 
  template<> 
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs); 
 
    #include <bits/codecvt.h> 
 
    class __num_base 
  { 
  public: 
            enum 
      { 
        _S_ominus, 
        _S_oplus, 
        _S_ox, 
        _S_oX, 
        _S_odigits, 
        _S_odigits_end = _S_odigits + 16, 
        _S_oudigits = _S_odigits_end, 
        _S_oudigits_end = _S_oudigits + 16, 
        _S_oe = _S_odigits + 14,          _S_oE = _S_oudigits + 14, 	_S_oend = _S_oudigits_end 
      }; 
 
                        static const char* _S_atoms_out; 
 
            static const char* _S_atoms_in; 
 
    enum 
    { 
      _S_iminus, 
      _S_iplus, 
      _S_ix, 
      _S_iX, 
      _S_izero, 
      _S_ie = _S_izero + 14, 
      _S_iE = _S_izero + 20, 
      _S_iend = 26 
    }; 
 
            static void 
    _S_format_float(const ios_base& __io, char* __fptr, char __mod); 
  }; 
 
  template<typename _CharT> 
    struct __numpunct_cache : public locale::facet 
    { 
      const char*			_M_grouping; 
      size_t                            _M_grouping_size; 
      bool				_M_use_grouping; 
      const _CharT*			_M_truename; 
      size_t                            _M_truename_size; 
      const _CharT*			_M_falsename; 
      size_t                            _M_falsename_size; 
      _CharT				_M_decimal_point; 
      _CharT				_M_thousands_sep; 
 
                              _CharT				_M_atoms_out[__num_base::_S_oend]; 
 
                              _CharT				_M_atoms_in[__num_base::_S_iend]; 
 
      bool				_M_allocated; 
 
      __numpunct_cache(size_t __refs = 0) : facet(__refs), 
      _M_grouping(NULL), _M_grouping_size(0), _M_use_grouping(false), 
      _M_truename(NULL), _M_truename_size(0), _M_falsename(NULL), 
      _M_falsename_size(0), _M_decimal_point(_CharT()), 
      _M_thousands_sep(_CharT()), _M_allocated(false) 
      { } 
 
      ~__numpunct_cache(); 
 
      void 
      _M_cache(const locale& __loc); 
 
    private: 
      __numpunct_cache& 
      operator=(const __numpunct_cache&); 
       
      explicit 
      __numpunct_cache(const __numpunct_cache&); 
    }; 
 
  template<typename _CharT> 
    __numpunct_cache<_CharT>::~__numpunct_cache() 
    { 
      if (_M_allocated) 
	{ 
	  delete [] _M_grouping; 
	  delete [] _M_truename; 
	  delete [] _M_falsename; 
	} 
    } 
 
  

  template<typename _CharT> 
    class numpunct : public locale::facet 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
            typedef __numpunct_cache<_CharT>  __cache_type; 
 
    protected: 
      __cache_type*			_M_data; 
 
    public: 
            static locale::id			id; 
 
      

      explicit 
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(NULL) 
      { _M_initialize_numpunct(); } 
 
      

      explicit 
      numpunct(__cache_type* __cache, size_t __refs = 0) 
      : facet(__refs), _M_data(__cache) 
      { _M_initialize_numpunct(); } 
 
      

      explicit 
      numpunct(__c_locale __cloc, size_t __refs = 0) 
      : facet(__refs), _M_data(NULL) 
      { _M_initialize_numpunct(__cloc); } 
 
      

      char_type 
      decimal_point() const 
      { return this->do_decimal_point(); } 
 
      

      char_type 
      thousands_sep() const 
      { return this->do_thousands_sep(); } 
 
      

      string 
      grouping() const 
      { return this->do_grouping(); } 
 
      

      string_type 
      truename() const 
      { return this->do_truename(); } 
 
      

      string_type 
      falsename() const 
      { return this->do_falsename(); } 
 
    protected: 
            virtual 
      ~numpunct(); 
 
      

      virtual char_type 
      do_decimal_point() const 
      { return _M_data->_M_decimal_point; } 
 
      

      virtual char_type 
      do_thousands_sep() const 
      { return _M_data->_M_thousands_sep; } 
 
      

      virtual string 
      do_grouping() const 
      { return _M_data->_M_grouping; } 
 
      

      virtual string_type 
      do_truename() const 
      { return _M_data->_M_truename; } 
 
      

      virtual string_type 
      do_falsename() const 
      { return _M_data->_M_falsename; } 
 
            void 
      _M_initialize_numpunct(__c_locale __cloc = NULL); 
    }; 
 
  template<typename _CharT> 
    locale::id numpunct<_CharT>::id; 
 
  template<> 
    numpunct<char>::~numpunct(); 
 
  template<> 
    void 
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc); 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    numpunct<wchar_t>::~numpunct(); 
 
  template<> 
    void 
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc); 
#endif 
 
    template<typename _CharT> 
    class numpunct_byname : public numpunct<_CharT> 
    { 
    public: 
      typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
 
      explicit 
      numpunct_byname(const char* __s, size_t __refs = 0) 
      : numpunct<_CharT>(__refs) 
      { 
	if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0) 
	  { 
	    __c_locale __tmp; 
	    this->_S_create_c_locale(__tmp, __s); 
	    this->_M_initialize_numpunct(__tmp); 
	    this->_S_destroy_c_locale(__tmp); 
	  } 
      } 
 
    protected: 
      virtual 
      ~numpunct_byname() { } 
    }; 
 
_GLIBCXX_BEGIN_LDBL_NAMESPACE 
  

  template<typename _CharT, typename _InIter> 
    class num_get : public locale::facet 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef _InIter			iter_type; 
       
            static locale::id			id; 
 
      

      explicit 
      num_get(size_t __refs = 0) : facet(__refs) { } 
 
      

      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, bool& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
            

      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, long& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, unsigned short& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, unsigned int& __v)   const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, unsigned long& __v)  const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, long long& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, unsigned long long& __v)  const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
#endif 
       
            

      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, float& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, double& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, long double& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
       
      

      iter_type 
      get(iter_type __in, iter_type __end, ios_base& __io, 
	  ios_base::iostate& __err, void*& __v) const 
      { return this->do_get(__in, __end, __io, __err, __v); } 
 
    protected: 
            virtual ~num_get() { } 
 
      iter_type 
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&, 
		       string& __xtrc) const; 
 
      template<typename _ValueT> 
        iter_type 
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, 
		       _ValueT& __v) const; 
 
            

      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const; 
 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const; 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	      unsigned short&) const; 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     unsigned int&) const; 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     unsigned long&) const; 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     long long&) const; 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     unsigned long long&) const; 
#endif 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     float&) const; 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     double&) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      __do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	       double&) const; 
#else 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     long double&) const; 
#endif 
 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     void*&) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, 
	     long double&) const; 
#endif 
          }; 
 
  template<typename _CharT, typename _InIter> 
    locale::id num_get<_CharT, _InIter>::id; 
 
 
  

  template<typename _CharT, typename _OutIter> 
    class num_put : public locale::facet 
    { 
    public: 
                        typedef _CharT		char_type; 
      typedef _OutIter		iter_type; 
       
            static locale::id		id; 
 
      

      explicit 
      num_put(size_t __refs = 0) : facet(__refs) { } 
 
      

      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
            

      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, 
	  unsigned long __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, 
	  unsigned long long __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
#endif 
       
            

      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, 
	  long double __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
       
      

      iter_type 
      put(iter_type __s, ios_base& __f, char_type __fill, 
	  const void* __v) const 
      { return this->do_put(__s, __f, __fill, __v); } 
 
    protected: 
      template<typename _ValueT> 
        iter_type 
        _M_insert_float(iter_type, ios_base& __io, char_type __fill, 
			char __mod, _ValueT __v) const; 
 
      void 
      _M_group_float(const char* __grouping, size_t __grouping_size, 
		     char_type __sep, const char_type* __p, char_type* __new, 
		     char_type* __cs, int& __len) const; 
 
      template<typename _ValueT> 
        iter_type 
        _M_insert_int(iter_type, ios_base& __io, char_type __fill, 
		      _ValueT __v) const; 
 
      void 
      _M_group_int(const char* __grouping, size_t __grouping_size, 
		   char_type __sep, ios_base& __io, char_type* __new, 
		   char_type* __cs, int& __len) const; 
 
      void 
      _M_pad(char_type __fill, streamsize __w, ios_base& __io, 
	     char_type* __new, const char_type* __cs, int& __len) const; 
 
            virtual 
      ~num_put() { }; 
 
            

      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const; 
 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, long __v) const; 
 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const; 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const; 
 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const; 
#endif 
 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, double __v) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      __do_put(iter_type, ios_base&, char_type __fill, double __v) const; 
#else 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const; 
#endif 
 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const; 
#endif 
          }; 
 
  template <typename _CharT, typename _OutIter> 
    locale::id num_put<_CharT, _OutIter>::id; 
 
_GLIBCXX_END_LDBL_NAMESPACE 
 
  

  template<typename _CharT> 
    class collate : public locale::facet 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
       
    protected: 
                  __c_locale			_M_c_locale_collate; 
 
    public: 
            static locale::id			id; 
 
      

      explicit 
      collate(size_t __refs = 0) 
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale()) 
      { } 
 
      

      explicit 
      collate(__c_locale __cloc, size_t __refs = 0) 
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) 
      { } 
 
      

      int 
      compare(const _CharT* __lo1, const _CharT* __hi1, 
	      const _CharT* __lo2, const _CharT* __hi2) const 
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); } 
 
      

      string_type 
      transform(const _CharT* __lo, const _CharT* __hi) const 
      { return this->do_transform(__lo, __hi); } 
 
      

      long 
      hash(const _CharT* __lo, const _CharT* __hi) const 
      { return this->do_hash(__lo, __hi); } 
 
            int 
      _M_compare(const _CharT*, const _CharT*) const; 
 
      size_t 
      _M_transform(_CharT*, const _CharT*, size_t) const; 
 
  protected: 
            virtual 
      ~collate() 
      { _S_destroy_c_locale(_M_c_locale_collate); } 
 
      

      virtual int 
      do_compare(const _CharT* __lo1, const _CharT* __hi1, 
		 const _CharT* __lo2, const _CharT* __hi2) const; 
 
      

      virtual string_type 
      do_transform(const _CharT* __lo, const _CharT* __hi) const; 
 
      

      virtual long 
      do_hash(const _CharT* __lo, const _CharT* __hi) const; 
    }; 
 
  template<typename _CharT> 
    locale::id collate<_CharT>::id; 
 
    template<> 
    int 
    collate<char>::_M_compare(const char*, const char*) const; 
 
  template<> 
    size_t 
    collate<char>::_M_transform(char*, const char*, size_t) const; 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    int 
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const; 
 
  template<> 
    size_t 
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const; 
#endif 
 
    template<typename _CharT> 
    class collate_byname : public collate<_CharT> 
    { 
    public: 
                  typedef _CharT               char_type; 
      typedef basic_string<_CharT> string_type; 
       
      explicit 
      collate_byname(const char* __s, size_t __refs = 0) 
      : collate<_CharT>(__refs) 
      { 
	if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0) 
	  { 
	    this->_S_destroy_c_locale(this->_M_c_locale_collate); 
	    this->_S_create_c_locale(this->_M_c_locale_collate, __s); 
	  } 
      } 
 
    protected: 
      virtual 
      ~collate_byname() { } 
    }; 
 
 
  

  class time_base 
  { 
  public: 
    enum dateorder { no_order, dmy, mdy, ymd, ydm }; 
  }; 
 
  template<typename _CharT> 
    struct __timepunct_cache : public locale::facet 
    { 
            static const _CharT*		_S_timezones[14]; 
 
      const _CharT*			_M_date_format; 
      const _CharT*			_M_date_era_format; 
      const _CharT*			_M_time_format; 
      const _CharT*			_M_time_era_format; 
      const _CharT*			_M_date_time_format; 
      const _CharT*			_M_date_time_era_format; 
      const _CharT*			_M_am; 
      const _CharT*			_M_pm; 
      const _CharT*			_M_am_pm_format; 
 
            const _CharT*			_M_day1; 
      const _CharT*			_M_day2; 
      const _CharT*			_M_day3; 
      const _CharT*			_M_day4; 
      const _CharT*			_M_day5; 
      const _CharT*			_M_day6; 
      const _CharT*			_M_day7; 
 
            const _CharT*			_M_aday1; 
      const _CharT*			_M_aday2; 
      const _CharT*			_M_aday3; 
      const _CharT*			_M_aday4; 
      const _CharT*			_M_aday5; 
      const _CharT*			_M_aday6; 
      const _CharT*			_M_aday7; 
 
            const _CharT*			_M_month01; 
      const _CharT*			_M_month02; 
      const _CharT*			_M_month03; 
      const _CharT*			_M_month04; 
      const _CharT*			_M_month05; 
      const _CharT*			_M_month06; 
      const _CharT*			_M_month07; 
      const _CharT*			_M_month08; 
      const _CharT*			_M_month09; 
      const _CharT*			_M_month10; 
      const _CharT*			_M_month11; 
      const _CharT*			_M_month12; 
 
            const _CharT*			_M_amonth01; 
      const _CharT*			_M_amonth02; 
      const _CharT*			_M_amonth03; 
      const _CharT*			_M_amonth04; 
      const _CharT*			_M_amonth05; 
      const _CharT*			_M_amonth06; 
      const _CharT*			_M_amonth07; 
      const _CharT*			_M_amonth08; 
      const _CharT*			_M_amonth09; 
      const _CharT*			_M_amonth10; 
      const _CharT*			_M_amonth11; 
      const _CharT*			_M_amonth12; 
 
      bool				_M_allocated; 
 
      __timepunct_cache(size_t __refs = 0) : facet(__refs), 
      _M_date_format(NULL), _M_date_era_format(NULL), _M_time_format(NULL), 
      _M_time_era_format(NULL), _M_date_time_format(NULL), 
      _M_date_time_era_format(NULL), _M_am(NULL), _M_pm(NULL), 
      _M_am_pm_format(NULL), _M_day1(NULL), _M_day2(NULL), _M_day3(NULL), 
      _M_day4(NULL), _M_day5(NULL), _M_day6(NULL), _M_day7(NULL), 
      _M_aday1(NULL), _M_aday2(NULL), _M_aday3(NULL), _M_aday4(NULL), 
      _M_aday5(NULL), _M_aday6(NULL), _M_aday7(NULL), _M_month01(NULL), 
      _M_month02(NULL), _M_month03(NULL), _M_month04(NULL), _M_month05(NULL), 
      _M_month06(NULL), _M_month07(NULL), _M_month08(NULL), _M_month09(NULL), 
      _M_month10(NULL), _M_month11(NULL), _M_month12(NULL), _M_amonth01(NULL), 
      _M_amonth02(NULL), _M_amonth03(NULL), _M_amonth04(NULL), 
      _M_amonth05(NULL), _M_amonth06(NULL), _M_amonth07(NULL), 
      _M_amonth08(NULL), _M_amonth09(NULL), _M_amonth10(NULL), 
      _M_amonth11(NULL), _M_amonth12(NULL), _M_allocated(false) 
      { } 
 
      ~__timepunct_cache(); 
 
      void 
      _M_cache(const locale& __loc); 
 
    private: 
      __timepunct_cache& 
      operator=(const __timepunct_cache&); 
       
      explicit 
      __timepunct_cache(const __timepunct_cache&); 
    }; 
 
  template<typename _CharT> 
    __timepunct_cache<_CharT>::~__timepunct_cache() 
    { 
      if (_M_allocated) 
	{ 
	  	} 
    } 
 
    template<> 
    const char* 
    __timepunct_cache<char>::_S_timezones[14]; 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    const wchar_t* 
    __timepunct_cache<wchar_t>::_S_timezones[14]; 
#endif 
 
    template<typename _CharT> 
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14]; 
 
  template<typename _CharT> 
    class __timepunct : public locale::facet 
    { 
    public: 
            typedef _CharT			__char_type; 
      typedef basic_string<_CharT>	__string_type; 
      typedef __timepunct_cache<_CharT>	__cache_type; 
 
    protected: 
      __cache_type*			_M_data; 
      __c_locale			_M_c_locale_timepunct; 
      const char*			_M_name_timepunct; 
 
    public: 
            static locale::id			id; 
 
      explicit 
      __timepunct(size_t __refs = 0); 
 
      explicit 
      __timepunct(__cache_type* __cache, size_t __refs = 0); 
 
      

      explicit 
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0); 
 
                  void 
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format, 
	     const tm* __tm) const; 
 
      void 
      _M_date_formats(const _CharT** __date) const 
      { 
		__date[0] = _M_data->_M_date_format; 
	__date[1] = _M_data->_M_date_era_format; 
      } 
 
      void 
      _M_time_formats(const _CharT** __time) const 
      { 
		__time[0] = _M_data->_M_time_format; 
	__time[1] = _M_data->_M_time_era_format; 
      } 
 
      void 
      _M_date_time_formats(const _CharT** __dt) const 
      { 
		__dt[0] = _M_data->_M_date_time_format; 
	__dt[1] = _M_data->_M_date_time_era_format; 
      } 
 
      void 
      _M_am_pm_format(const _CharT* __ampm) const 
      { __ampm = _M_data->_M_am_pm_format; } 
 
      void 
      _M_am_pm(const _CharT** __ampm) const 
      { 
	__ampm[0] = _M_data->_M_am; 
	__ampm[1] = _M_data->_M_pm; 
      } 
 
      void 
      _M_days(const _CharT** __days) const 
      { 
	__days[0] = _M_data->_M_day1; 
	__days[1] = _M_data->_M_day2; 
	__days[2] = _M_data->_M_day3; 
	__days[3] = _M_data->_M_day4; 
	__days[4] = _M_data->_M_day5; 
	__days[5] = _M_data->_M_day6; 
	__days[6] = _M_data->_M_day7; 
      } 
 
      void 
      _M_days_abbreviated(const _CharT** __days) const 
      { 
	__days[0] = _M_data->_M_aday1; 
	__days[1] = _M_data->_M_aday2; 
	__days[2] = _M_data->_M_aday3; 
	__days[3] = _M_data->_M_aday4; 
	__days[4] = _M_data->_M_aday5; 
	__days[5] = _M_data->_M_aday6; 
	__days[6] = _M_data->_M_aday7; 
      } 
 
      void 
      _M_months(const _CharT** __months) const 
      { 
	__months[0] = _M_data->_M_month01; 
	__months[1] = _M_data->_M_month02; 
	__months[2] = _M_data->_M_month03; 
	__months[3] = _M_data->_M_month04; 
	__months[4] = _M_data->_M_month05; 
	__months[5] = _M_data->_M_month06; 
	__months[6] = _M_data->_M_month07; 
	__months[7] = _M_data->_M_month08; 
	__months[8] = _M_data->_M_month09; 
	__months[9] = _M_data->_M_month10; 
	__months[10] = _M_data->_M_month11; 
	__months[11] = _M_data->_M_month12; 
      } 
 
      void 
      _M_months_abbreviated(const _CharT** __months) const 
      { 
	__months[0] = _M_data->_M_amonth01; 
	__months[1] = _M_data->_M_amonth02; 
	__months[2] = _M_data->_M_amonth03; 
	__months[3] = _M_data->_M_amonth04; 
	__months[4] = _M_data->_M_amonth05; 
	__months[5] = _M_data->_M_amonth06; 
	__months[6] = _M_data->_M_amonth07; 
	__months[7] = _M_data->_M_amonth08; 
	__months[8] = _M_data->_M_amonth09; 
	__months[9] = _M_data->_M_amonth10; 
	__months[10] = _M_data->_M_amonth11; 
	__months[11] = _M_data->_M_amonth12; 
      } 
 
    protected: 
      virtual 
      ~__timepunct(); 
 
            void 
      _M_initialize_timepunct(__c_locale __cloc = NULL); 
    }; 
 
  template<typename _CharT> 
    locale::id __timepunct<_CharT>::id; 
 
    template<> 
    void 
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc); 
 
  template<> 
    void 
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const; 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    void 
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc); 
 
  template<> 
    void 
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*, 
				 const tm*) const; 
#endif 
 
    #include <bits/time_members.h> 
 
  

  template<typename _CharT, typename _InIter> 
    class time_get : public locale::facet, public time_base 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef _InIter			iter_type; 
            typedef basic_string<_CharT>	__string_type; 
 
            static locale::id			id; 
 
      

      explicit 
      time_get(size_t __refs = 0) 
      : facet (__refs) { } 
 
      

      dateorder 
      date_order()  const 
      { return this->do_date_order(); } 
 
      

      iter_type 
      get_time(iter_type __beg, iter_type __end, ios_base& __io, 
	       ios_base::iostate& __err, tm* __tm)  const 
      { return this->do_get_time(__beg, __end, __io, __err, __tm); } 
 
      

      iter_type 
      get_date(iter_type __beg, iter_type __end, ios_base& __io, 
	       ios_base::iostate& __err, tm* __tm)  const 
      { return this->do_get_date(__beg, __end, __io, __err, __tm); } 
 
      

      iter_type 
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io, 
		  ios_base::iostate& __err, tm* __tm) const 
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); } 
 
      

      iter_type 
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io, 
		    ios_base::iostate& __err, tm* __tm) const 
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); } 
 
      

      iter_type 
      get_year(iter_type __beg, iter_type __end, ios_base& __io, 
	       ios_base::iostate& __err, tm* __tm) const 
      { return this->do_get_year(__beg, __end, __io, __err, __tm); } 
 
    protected: 
            virtual 
      ~time_get() { } 
 
      

      virtual dateorder 
      do_date_order() const; 
 
      

      virtual iter_type 
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io, 
		  ios_base::iostate& __err, tm* __tm) const; 
 
      

      virtual iter_type 
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io, 
		  ios_base::iostate& __err, tm* __tm) const; 
 
      

      virtual iter_type 
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&, 
		     ios_base::iostate& __err, tm* __tm) const; 
 
      

      virtual iter_type 
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&, 
		       ios_base::iostate& __err, tm* __tm) const; 
 
      

      virtual iter_type 
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io, 
		  ios_base::iostate& __err, tm* __tm) const; 
 
            iter_type 
      _M_extract_num(iter_type __beg, iter_type __end, int& __member, 
		     int __min, int __max, size_t __len, 
		     ios_base& __io, ios_base::iostate& __err) const; 
 
                  iter_type 
      _M_extract_name(iter_type __beg, iter_type __end, int& __member, 
		      const _CharT** __names, size_t __indexlen, 
		      ios_base& __io, ios_base::iostate& __err) const; 
 
            iter_type 
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io, 
			    ios_base::iostate& __err, tm* __tm, 
			    const _CharT* __format) const; 
    }; 
 
  template<typename _CharT, typename _InIter> 
    locale::id time_get<_CharT, _InIter>::id; 
 
    template<typename _CharT, typename _InIter> 
    class time_get_byname : public time_get<_CharT, _InIter> 
    { 
    public: 
            typedef _CharT			char_type; 
      typedef _InIter			iter_type; 
 
      explicit 
      time_get_byname(const char*, size_t __refs = 0) 
      : time_get<_CharT, _InIter>(__refs) { } 
 
    protected: 
      virtual 
      ~time_get_byname() { } 
    }; 
 
  

  template<typename _CharT, typename _OutIter> 
    class time_put : public locale::facet 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef _OutIter			iter_type; 
       
            static locale::id			id; 
 
      

      explicit 
      time_put(size_t __refs = 0) 
      : facet(__refs) { } 
 
      

      iter_type 
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, 
	  const _CharT* __beg, const _CharT* __end) const; 
 
      

      iter_type 
      put(iter_type __s, ios_base& __io, char_type __fill, 
	  const tm* __tm, char __format, char __mod = 0) const 
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); } 
 
    protected: 
            virtual 
      ~time_put() 
      { } 
 
      

      virtual iter_type 
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, 
	     char __format, char __mod) const; 
    }; 
 
  template<typename _CharT, typename _OutIter> 
    locale::id time_put<_CharT, _OutIter>::id; 
 
    template<typename _CharT, typename _OutIter> 
    class time_put_byname : public time_put<_CharT, _OutIter> 
    { 
    public: 
            typedef _CharT			char_type; 
      typedef _OutIter			iter_type; 
 
      explicit 
      time_put_byname(const char*, size_t __refs = 0) 
      : time_put<_CharT, _OutIter>(__refs) 
      { }; 
 
    protected: 
      virtual 
      ~time_put_byname() { } 
    }; 
 
 
  

  class money_base 
  { 
  public: 
    enum part { none, space, symbol, sign, value }; 
    struct pattern { char field[4]; }; 
 
    static const pattern _S_default_pattern; 
 
    enum 
    { 
      _S_minus, 
      _S_zero, 
      _S_end = 11 
    }; 
 
            static const char* _S_atoms; 
 
            static pattern 
    _S_construct_pattern(char __precedes, char __space, char __posn); 
  }; 
 
  template<typename _CharT, bool _Intl> 
    struct __moneypunct_cache : public locale::facet 
    { 
      const char*			_M_grouping; 
      size_t                            _M_grouping_size; 
      bool				_M_use_grouping; 
      _CharT				_M_decimal_point; 
      _CharT				_M_thousands_sep; 
      const _CharT*			_M_curr_symbol; 
      size_t                            _M_curr_symbol_size; 
      const _CharT*			_M_positive_sign; 
      size_t                            _M_positive_sign_size; 
      const _CharT*			_M_negative_sign; 
      size_t                            _M_negative_sign_size; 
      int				_M_frac_digits; 
      money_base::pattern		_M_pos_format; 
      money_base::pattern	        _M_neg_format; 
 
                        _CharT				_M_atoms[money_base::_S_end]; 
 
      bool				_M_allocated; 
 
      __moneypunct_cache(size_t __refs = 0) : facet(__refs), 
      _M_grouping(NULL), _M_grouping_size(0), _M_use_grouping(false), 
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), 
      _M_curr_symbol(NULL), _M_curr_symbol_size(0), 
      _M_positive_sign(NULL), _M_positive_sign_size(0), 
      _M_negative_sign(NULL), _M_negative_sign_size(0), 
      _M_frac_digits(0), 
      _M_pos_format(money_base::pattern()), 
      _M_neg_format(money_base::pattern()), _M_allocated(false) 
      { } 
 
      ~__moneypunct_cache(); 
 
      void 
      _M_cache(const locale& __loc); 
 
    private: 
      __moneypunct_cache& 
      operator=(const __moneypunct_cache&); 
       
      explicit 
      __moneypunct_cache(const __moneypunct_cache&); 
    }; 
 
  template<typename _CharT, bool _Intl> 
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache() 
    { 
      if (_M_allocated) 
	{ 
	  delete [] _M_grouping; 
	  delete [] _M_curr_symbol; 
	  delete [] _M_positive_sign; 
	  delete [] _M_negative_sign; 
	} 
    } 
 
  

  template<typename _CharT, bool _Intl> 
    class moneypunct : public locale::facet, public money_base 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
            typedef __moneypunct_cache<_CharT, _Intl>     __cache_type; 
 
    private: 
      __cache_type*			_M_data; 
 
    public: 
                  static const bool			intl = _Intl; 
            static locale::id			id; 
 
      

      explicit 
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(NULL) 
      { _M_initialize_moneypunct(); } 
 
      

      explicit 
      moneypunct(__cache_type* __cache, size_t __refs = 0) 
      : facet(__refs), _M_data(__cache) 
      { _M_initialize_moneypunct(); } 
 
      

      explicit 
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0) 
      : facet(__refs), _M_data(NULL) 
      { _M_initialize_moneypunct(__cloc, __s); } 
 
      

      char_type 
      decimal_point() const 
      { return this->do_decimal_point(); } 
 
      

      char_type 
      thousands_sep() const 
      { return this->do_thousands_sep(); } 
 
      

      string 
      grouping() const 
      { return this->do_grouping(); } 
 
      

      string_type 
      curr_symbol() const 
      { return this->do_curr_symbol(); } 
 
      

      string_type 
      positive_sign() const 
      { return this->do_positive_sign(); } 
 
      

      string_type 
      negative_sign() const 
      { return this->do_negative_sign(); } 
 
      

      int 
      frac_digits() const 
      { return this->do_frac_digits(); } 
 
            

      pattern 
      pos_format() const 
      { return this->do_pos_format(); } 
 
      pattern 
      neg_format() const 
      { return this->do_neg_format(); } 
       
    protected: 
            virtual 
      ~moneypunct(); 
 
      

      virtual char_type 
      do_decimal_point() const 
      { return _M_data->_M_decimal_point; } 
 
      

      virtual char_type 
      do_thousands_sep() const 
      { return _M_data->_M_thousands_sep; } 
 
      

      virtual string 
      do_grouping() const 
      { return _M_data->_M_grouping; } 
 
      

      virtual string_type 
      do_curr_symbol()   const 
      { return _M_data->_M_curr_symbol; } 
 
      

      virtual string_type 
      do_positive_sign() const 
      { return _M_data->_M_positive_sign; } 
 
      

      virtual string_type 
      do_negative_sign() const 
      { return _M_data->_M_negative_sign; } 
 
      

      virtual int 
      do_frac_digits() const 
      { return _M_data->_M_frac_digits; } 
 
      

      virtual pattern 
      do_pos_format() const 
      { return _M_data->_M_pos_format; } 
 
      

      virtual pattern 
      do_neg_format() const 
      { return _M_data->_M_neg_format; } 
 
             void 
       _M_initialize_moneypunct(__c_locale __cloc = NULL, 
				const char* __name = NULL); 
    }; 
 
  template<typename _CharT, bool _Intl> 
    locale::id moneypunct<_CharT, _Intl>::id; 
 
  template<typename _CharT, bool _Intl> 
    const bool moneypunct<_CharT, _Intl>::intl; 
 
  template<> 
    moneypunct<char, true>::~moneypunct(); 
 
  template<> 
    moneypunct<char, false>::~moneypunct(); 
 
  template<> 
    void 
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*); 
 
  template<> 
    void 
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*); 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    moneypunct<wchar_t, true>::~moneypunct(); 
 
  template<> 
    moneypunct<wchar_t, false>::~moneypunct(); 
 
  template<> 
    void 
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale, 
							const char*); 
 
  template<> 
    void 
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale, 
							 const char*); 
#endif 
 
    template<typename _CharT, bool _Intl> 
    class moneypunct_byname : public moneypunct<_CharT, _Intl> 
    { 
    public: 
      typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
 
      static const bool intl = _Intl; 
 
      explicit 
      moneypunct_byname(const char* __s, size_t __refs = 0) 
      : moneypunct<_CharT, _Intl>(__refs) 
      { 
	if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0) 
	  { 
	    __c_locale __tmp; 
	    this->_S_create_c_locale(__tmp, __s); 
	    this->_M_initialize_moneypunct(__tmp); 
	    this->_S_destroy_c_locale(__tmp); 
	  } 
      } 
 
    protected: 
      virtual 
      ~moneypunct_byname() { } 
    }; 
 
  template<typename _CharT, bool _Intl> 
    const bool moneypunct_byname<_CharT, _Intl>::intl; 
 
_GLIBCXX_BEGIN_LDBL_NAMESPACE 
  

  template<typename _CharT, typename _InIter> 
    class money_get : public locale::facet 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef _InIter			iter_type; 
      typedef basic_string<_CharT>	string_type; 
       
            static locale::id			id; 
 
      

      explicit 
      money_get(size_t __refs = 0) : facet(__refs) { } 
 
      

      iter_type 
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	  ios_base::iostate& __err, long double& __units) const 
      { return this->do_get(__s, __end, __intl, __io, __err, __units); } 
 
      

      iter_type 
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	  ios_base::iostate& __err, string_type& __digits) const 
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); } 
 
    protected: 
            virtual 
      ~money_get() { } 
 
      

      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      __do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	       ios_base::iostate& __err, double& __units) const; 
#else 
      virtual iter_type 
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	     ios_base::iostate& __err, long double& __units) const; 
#endif 
 
      

      virtual iter_type 
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	     ios_base::iostate& __err, string_type& __digits) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, 
	     ios_base::iostate& __err, long double& __units) const; 
#endif 
 
      template<bool _Intl> 
        iter_type 
        _M_extract(iter_type __s, iter_type __end, ios_base& __io, 
		   ios_base::iostate& __err, string& __digits) const;      
    }; 
 
  template<typename _CharT, typename _InIter> 
    locale::id money_get<_CharT, _InIter>::id; 
 
  

  template<typename _CharT, typename _OutIter> 
    class money_put : public locale::facet 
    { 
    public: 
                  typedef _CharT			char_type; 
      typedef _OutIter			iter_type; 
      typedef basic_string<_CharT>	string_type; 
       
            static locale::id			id; 
 
      

      explicit 
      money_put(size_t __refs = 0) : facet(__refs) { } 
 
      

      iter_type 
      put(iter_type __s, bool __intl, ios_base& __io, 
	  char_type __fill, long double __units) const 
      { return this->do_put(__s, __intl, __io, __fill, __units); } 
 
      

      iter_type 
      put(iter_type __s, bool __intl, ios_base& __io, 
	  char_type __fill, const string_type& __digits) const 
      { return this->do_put(__s, __intl, __io, __fill, __digits); } 
 
    protected: 
            virtual 
      ~money_put() { } 
 
      

      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      __do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill, 
	       double __units) const; 
#else 
      virtual iter_type 
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill, 
	     long double __units) const; 
#endif 
 
      

      virtual iter_type 
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill, 
	     const string_type& __digits) const; 
 
      #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ 
      virtual iter_type 
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill, 
	     long double __units) const; 
#endif 
 
      template<bool _Intl> 
        iter_type 
        _M_insert(iter_type __s, ios_base& __io, char_type __fill, 
		  const string_type& __digits) const; 
    }; 
 
  template<typename _CharT, typename _OutIter> 
    locale::id money_put<_CharT, _OutIter>::id; 
 
_GLIBCXX_END_LDBL_NAMESPACE 
 
  

  struct messages_base 
  { 
    typedef int catalog; 
  }; 
 
  

  template<typename _CharT> 
    class messages : public locale::facet, public messages_base 
    { 
    public: 
                        typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
       
    protected: 
                  __c_locale			_M_c_locale_messages; 
      const char*			_M_name_messages; 
 
    public: 
            static locale::id			id; 
 
      

      explicit 
      messages(size_t __refs = 0); 
 
            

      explicit 
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0); 
 
      

      catalog 
      open(const basic_string<char>& __s, const locale& __loc) const 
      { return this->do_open(__s, __loc); } 
 
            

      catalog 
      open(const basic_string<char>&, const locale&, const char*) const; 
 
      

      string_type 
      get(catalog __c, int __set, int __msgid, const string_type& __s) const 
      { return this->do_get(__c, __set, __msgid, __s); } 
 
      

      void 
      close(catalog __c) const 
      { return this->do_close(__c); } 
 
    protected: 
            virtual 
      ~messages(); 
 
      

      virtual catalog 
      do_open(const basic_string<char>&, const locale&) const; 
 
      

      virtual string_type 
      do_get(catalog, int, int, const string_type& __dfault) const; 
 
      

      virtual void 
      do_close(catalog) const; 
 
            char* 
      _M_convert_to_char(const string_type& __msg) const 
      { 
		return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str())); 
      } 
 
            string_type 
      _M_convert_from_char(char*) const 
      { 
#if 0 
		size_t __len = char_traits<char>::length(__msg) - 1; 
 
		 
				typedef typename codecvt<char, _CharT, mbstate_t> __codecvt_type; 
 
	__codecvt_type::state_type __state; 
		 
	char* __from_next; 
		_CharT* __to = static_cast<_CharT*>(__builtin_alloca(__len + 1)); 
	const __codecvt_type& __cvt = use_facet<__codecvt_type>(_M_locale_conv); 
	__cvt.out(__state, __msg, __msg + __len, __from_next, 
		  __to, __to + __len + 1, __to_next); 
	return string_type(__to); 
#endif 
#if 0 
	typedef ctype<_CharT> __ctype_type; 
		const __ctype_type& __cvt = use_facet<__ctype_type>(locale()); 
			_CharT* __dest = static_cast<_CharT*>(__builtin_alloca(__len + 1)); 
	__cvt.widen(__msg, __msg + __len, __dest); 
	return basic_string<_CharT>(__dest); 
#endif 
	return string_type(); 
      } 
     }; 
 
  template<typename _CharT> 
    locale::id messages<_CharT>::id; 
 
    template<> 
    string 
    messages<char>::do_get(catalog, int, int, const string&) const; 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<> 
    wstring 
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const; 
#endif 
 
      template<typename _CharT> 
    class messages_byname : public messages<_CharT> 
    { 
    public: 
      typedef _CharT			char_type; 
      typedef basic_string<_CharT>	string_type; 
 
      explicit 
      messages_byname(const char* __s, size_t __refs = 0); 
 
    protected: 
      virtual 
      ~messages_byname() 
      { } 
    }; 
 
    #include <bits/messages_members.h> 
 
 
         
    template<typename _CharT> 
    inline bool 
    isspace(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isprint(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); } 
 
    template<typename _CharT> 
    inline bool 
    iscntrl(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isupper(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); } 
 
    template<typename _CharT> 
    inline bool  
    islower(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isalpha(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isdigit(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); } 
 
    template<typename _CharT> 
    inline bool 
    ispunct(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isxdigit(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isalnum(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); } 
 
    template<typename _CharT> 
    inline bool 
    isgraph(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); } 
 
    template<typename _CharT> 
    inline _CharT 
    toupper(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); } 
 
    template<typename _CharT> 
    inline _CharT 
    tolower(_CharT __c, const locale& __loc) 
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); } 
}  
#endif 
 
 
namespace std 
{ 
    

  template<typename _CharT, typename _Traits> 
    class basic_ios : public ios_base 
    { 
    public: 
            

      typedef _CharT                                 char_type; 
      typedef typename _Traits::int_type             int_type; 
      typedef typename _Traits::pos_type             pos_type; 
      typedef typename _Traits::off_type             off_type; 
      typedef _Traits                                traits_type; 
       
            

      typedef ctype<_CharT>                          __ctype_type; 
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > 
						     __num_put_type; 
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > 
						     __num_get_type; 
       
          protected: 
      basic_ostream<_CharT, _Traits>*                _M_tie; 
      mutable char_type                              _M_fill; 
      mutable bool                                   _M_fill_init; 
      basic_streambuf<_CharT, _Traits>*              _M_streambuf; 
 
            const __ctype_type*                            _M_ctype; 
            const __num_put_type*                          _M_num_put; 
            const __num_get_type*                          _M_num_get; 
 
    public: 
            

      operator void*() const 
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); } 
 
      bool 
      operator!() const 
      { return this->fail(); } 
       
      

      iostate 
      rdstate() const 
      { return _M_streambuf_state; } 
 
      

      void 
      clear(iostate __state = goodbit); 
 
      

      void 
      setstate(iostate __state) 
      { this->clear(this->rdstate() | __state); } 
 
                        void 
      _M_setstate(iostate __state) 
      { 
			_M_streambuf_state |= __state; 
	if (this->exceptions() & __state) 
	  __throw_exception_again; 
      } 
 
      

      bool 
      good() const 
      { return this->rdstate() == 0; } 
 
      

      bool 
      eof() const 
      { return (this->rdstate() & eofbit) != 0; } 
 
      

      bool 
      fail() const 
      { return (this->rdstate() & (badbit | failbit)) != 0; } 
 
      

      bool 
      bad() const 
      { return (this->rdstate() & badbit) != 0; } 
 
      

      iostate 
      exceptions() const 
      { return _M_exception; } 
 
      

      void 
      exceptions(iostate __except) 
      { 
        _M_exception = __except; 
        this->clear(_M_streambuf_state); 
      } 
 
            

      explicit 
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) 
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), 
      _M_ctype(0), _M_num_put(0), _M_num_get(0) 
      { this->init(__sb); } 
 
      

      virtual 
      ~basic_ios() { } 
 
            

      basic_ostream<_CharT, _Traits>* 
      tie() const 
      { return _M_tie; } 
 
      

      basic_ostream<_CharT, _Traits>* 
      tie(basic_ostream<_CharT, _Traits>* __tiestr) 
      { 
        basic_ostream<_CharT, _Traits>* __old = _M_tie; 
        _M_tie = __tiestr; 
        return __old; 
      } 
 
      

      basic_streambuf<_CharT, _Traits>* 
      rdbuf() const 
      { return _M_streambuf; } 
 
      

      basic_streambuf<_CharT, _Traits>* 
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb); 
 
      

      basic_ios& 
      copyfmt(const basic_ios& __rhs); 
 
      

      char_type 
      fill() const 
      { 
	if (!_M_fill_init) 
	  { 
	    _M_fill = this->widen(' '); 
	    _M_fill_init = true; 
	  } 
	return _M_fill; 
      } 
 
      

      char_type 
      fill(char_type __ch) 
      { 
	char_type __old = this->fill(); 
	_M_fill = __ch; 
	return __old; 
      } 
 
            

      locale 
      imbue(const locale& __loc); 
 
      

      char 
      narrow(char_type __c, char __dfault) const; 
 
      

      char_type 
      widen(char __c) const; 
 
    protected: 
            

      basic_ios() 
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),  
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) 
      { } 
 
      

      void 
      init(basic_streambuf<_CharT, _Traits>* __sb); 
 
      void 
      _M_cache_locale(const locale& __loc); 
    }; 
}  
#ifndef _GLIBCXX_EXPORT_TEMPLATE 
 
 
 
 
 


 
#ifndef _BASIC_IOS_TCC 
 
#pragma GCC system_header 
 
namespace std 
{ 
  template<typename _CharT, typename _Traits> 
    void 
    basic_ios<_CharT, _Traits>::clear(iostate __state) 
    { 
      if (this->rdbuf()) 
	_M_streambuf_state = __state; 
      else 
	  _M_streambuf_state = __state | badbit; 
      if (this->exceptions() & this->rdstate()) 
	__throw_ios_failure(__N("basic_ios::clear")); 
    } 
 
  template<typename _CharT, typename _Traits> 
    basic_streambuf<_CharT, _Traits>* 
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb) 
    { 
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf; 
      _M_streambuf = __sb; 
      this->clear(); 
      return __old; 
    } 
 
  template<typename _CharT, typename _Traits> 
    basic_ios<_CharT, _Traits>& 
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs) 
    { 
                  if (this != &__rhs) 
	{ 
	  	   
	  	  _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ? 
	                     _M_local_word : new _Words[__rhs._M_word_size]; 
 
	  	  _Callback_list* __cb = __rhs._M_callbacks; 
	  if (__cb) 
	    __cb->_M_add_reference(); 
	  _M_call_callbacks(erase_event); 
	  if (_M_word != _M_local_word) 
	    { 
	      delete [] _M_word; 
	      _M_word = 0; 
	    } 
	  _M_dispose_callbacks(); 
 
	  	  _M_callbacks = __cb; 
	  for (int __i = 0; __i < __rhs._M_word_size; ++__i) 
	    __words[__i] = __rhs._M_word[__i]; 
	  _M_word = __words; 
	  _M_word_size = __rhs._M_word_size; 
 
	  this->flags(__rhs.flags()); 
	  this->width(__rhs.width()); 
	  this->precision(__rhs.precision()); 
	  this->tie(__rhs.tie()); 
	  this->fill(__rhs.fill()); 
	  _M_ios_locale = __rhs.getloc(); 
	  _M_cache_locale(_M_ios_locale); 
 
	  _M_call_callbacks(copyfmt_event); 
 
	  	  this->exceptions(__rhs.exceptions()); 
	} 
      return *this; 
    } 
 
  template<typename _CharT, typename _Traits> 
    char 
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const 
    { return __check_facet(_M_ctype).narrow(__c, __dfault); } 
 
  template<typename _CharT, typename _Traits> 
    _CharT 
    basic_ios<_CharT, _Traits>::widen(char __c) const 
    { return __check_facet(_M_ctype).widen(__c); } 
 
    template<typename _CharT, typename _Traits> 
    locale 
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc) 
    { 
      locale __old(this->getloc()); 
      ios_base::imbue(__loc); 
      _M_cache_locale(__loc); 
      if (this->rdbuf() != 0) 
	this->rdbuf()->pubimbue(__loc); 
      return __old; 
    } 
 
  template<typename _CharT, typename _Traits> 
    void 
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb) 
    { 
            ios_base::_M_init(); 
 
            _M_cache_locale(_M_ios_locale); 
 
                                                                              _M_fill = _CharT(); 
      _M_fill_init = false; 
 
      _M_tie = 0; 
      _M_exception = goodbit; 
      _M_streambuf = __sb; 
      _M_streambuf_state = __sb ? goodbit : badbit; 
    } 
 
  template<typename _CharT, typename _Traits> 
    void 
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc) 
    { 
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true)) 
	_M_ctype = &use_facet<__ctype_type>(__loc); 
      else 
	_M_ctype = 0; 
 
      if (__builtin_expect(has_facet<__num_put_type>(__loc), true)) 
	_M_num_put = &use_facet<__num_put_type>(__loc); 
      else 
	_M_num_put = 0; 
 
      if (__builtin_expect(has_facet<__num_get_type>(__loc), true)) 
	_M_num_get = &use_facet<__num_get_type>(__loc); 
      else 
	_M_num_get = 0; 
    } 
 
      #if _GLIBCXX_EXTERN_TEMPLATE 
  extern template class basic_ios<char>; 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  extern template class basic_ios<wchar_t>; 
#endif 
#endif 
}  
#endif 
 
#endif 
 
#endif 
 
#endif	
 
namespace std 
{ 
    

  template<typename _CharT, typename _Traits> 
    class basic_ostream : virtual public basic_ios<_CharT, _Traits> 
    { 
    public: 
            typedef _CharT                     		char_type; 
      typedef typename _Traits::int_type 		int_type; 
      typedef typename _Traits::pos_type 		pos_type; 
      typedef typename _Traits::off_type 		off_type; 
      typedef _Traits                    		traits_type; 
       
            typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type; 
      typedef basic_ios<_CharT, _Traits>		__ios_type; 
      typedef basic_ostream<_CharT, _Traits>		__ostream_type; 
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >         
      							__num_put_type; 
      typedef ctype<_CharT>           			__ctype_type; 
 
      template<typename _CharT2, typename _Traits2> 
        friend basic_ostream<_CharT2, _Traits2>& 
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2); 
  
      template<typename _Traits2> 
        friend basic_ostream<char, _Traits2>& 
        operator<<(basic_ostream<char, _Traits2>&, char); 
  
      template<typename _CharT2, typename _Traits2> 
        friend basic_ostream<_CharT2, _Traits2>& 
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*); 
  
      template<typename _Traits2> 
        friend basic_ostream<char, _Traits2>& 
        operator<<(basic_ostream<char, _Traits2>&, const char*); 
  
      template<typename _CharT2, typename _Traits2> 
        friend basic_ostream<_CharT2, _Traits2>& 
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*); 
 
            

      explicit  
      basic_ostream(__streambuf_type* __sb) 
      { this->init(__sb); } 
 
      

      virtual  
      ~basic_ostream() { } 
 
            class sentry; 
      friend class sentry; 
       
                        

      inline __ostream_type& 
      operator<<(__ostream_type& (*__pf)(__ostream_type&)); 
       
      inline __ostream_type& 
      operator<<(__ios_type& (*__pf)(__ios_type&)); 
       
      inline __ostream_type& 
      operator<<(ios_base& (*__pf) (ios_base&)); 
       
            

            

      __ostream_type&  
      operator<<(long __n); 
       
      __ostream_type&  
      operator<<(unsigned long __n); 
 
      __ostream_type&  
      operator<<(bool __n); 
 
      __ostream_type&  
      operator<<(short __n); 
 
      __ostream_type&  
      operator<<(unsigned short __n); 
 
      __ostream_type&  
      operator<<(int __n); 
 
      __ostream_type&  
      operator<<(unsigned int __n); 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      __ostream_type&  
      operator<<(long long __n); 
 
      __ostream_type&  
      operator<<(unsigned long long __n); 
#endif 
 
      __ostream_type&  
      operator<<(double __f); 
 
      __ostream_type&  
      operator<<(float __f); 
 
      __ostream_type&  
      operator<<(long double __f); 
 
      __ostream_type&  
      operator<<(const void* __p); 
 
      

      __ostream_type&  
      operator<<(__streambuf_type* __sb); 
       
            

            

      __ostream_type&  
      put(char_type __c); 
 
            void 
      _M_write(const char_type* __s, streamsize __n) 
      { 
	streamsize __put = this->rdbuf()->sputn(__s, __n); 
	if (__put != __n) 
	  this->setstate(ios_base::badbit); 
      } 
 
      

      __ostream_type&  
      write(const char_type* __s, streamsize __n); 
       
      

      __ostream_type&  
      flush(); 
 
            

      pos_type  
      tellp(); 
 
      

      __ostream_type&  
      seekp(pos_type); 
 
      

       __ostream_type&  
      seekp(off_type, ios_base::seekdir); 
       
    protected: 
      explicit  
      basic_ostream() { } 
    }; 
 
  

  template <typename _CharT, typename _Traits> 
    class basic_ostream<_CharT, _Traits>::sentry 
    { 
            bool 				_M_ok; 
      basic_ostream<_CharT,_Traits>& 	_M_os; 
       
    public: 
      

      explicit 
      sentry(basic_ostream<_CharT,_Traits>& __os); 
 
      

      ~sentry() 
      { 
		if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception()) 
	  { 
	    	    if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1) 
	      _M_os.setstate(ios_base::badbit); 
	  } 
      } 
 
      

      operator bool() const 
      { return _M_ok; } 
    }; 
 
      

  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>& 
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c); 
 
  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>& 
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c) 
    { return (__out << __out.widen(__c)); } 
 
    template <class _Traits>  
    basic_ostream<char, _Traits>& 
    operator<<(basic_ostream<char, _Traits>& __out, char __c); 
 
    template<class _Traits> 
    basic_ostream<char, _Traits>& 
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c) 
    { return (__out << static_cast<char>(__c)); } 
   
  template<class _Traits> 
    basic_ostream<char, _Traits>& 
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c) 
    { return (__out << static_cast<char>(__c)); } 
     
    

  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>& 
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s); 
 
  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits> & 
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s); 
 
    template<class _Traits> 
    basic_ostream<char, _Traits>& 
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s); 
  
    template<class _Traits> 
    basic_ostream<char, _Traits>& 
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s) 
    { return (__out << reinterpret_cast<const char*>(__s)); } 
 
  template<class _Traits> 
    basic_ostream<char, _Traits> & 
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s) 
    { return (__out << reinterpret_cast<const char*>(__s)); } 
   
    

  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>&  
    endl(basic_ostream<_CharT, _Traits>& __os) 
    { return flush(__os.put(__os.widen('\n'))); } 
 
  

  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>&  
    ends(basic_ostream<_CharT, _Traits>& __os) 
    { return __os.put(_CharT()); } 
   
  

  template<typename _CharT, typename _Traits> 
    basic_ostream<_CharT, _Traits>&  
    flush(basic_ostream<_CharT, _Traits>& __os) 
    { return __os.flush(); } 
 
}  
#ifndef _GLIBCXX_EXPORT_TEMPLATE 
# include <bits/ostream.tcc> 
#endif 
 
#endif	
 
 
 
 
 
 


 
#ifndef _GLIBCXX_ISTREAM 
 
#pragma GCC system_header 
 
#include <limits>  
namespace std 
{ 
    

  template<typename _CharT, typename _Traits> 
    class basic_istream : virtual public basic_ios<_CharT, _Traits> 
    { 
    public: 
            typedef _CharT                     		char_type; 
      typedef typename _Traits::int_type 		int_type; 
      typedef typename _Traits::pos_type 		pos_type; 
      typedef typename _Traits::off_type 		off_type; 
      typedef _Traits                    		traits_type; 
       
            typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type; 
      typedef basic_ios<_CharT, _Traits>		__ios_type; 
      typedef basic_istream<_CharT, _Traits>		__istream_type; 
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >         
 							__num_get_type; 
      typedef ctype<_CharT>           			__ctype_type; 
 
      template<typename _CharT2, typename _Traits2> 
        friend basic_istream<_CharT2, _Traits2>& 
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&); 
  
      template<typename _CharT2, typename _Traits2> 
        friend basic_istream<_CharT2, _Traits2>& 
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*); 
  
    protected: 
            

      streamsize 		_M_gcount; 
 
    public: 
            

      explicit  
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0)) 
      { this->init(__sb); } 
 
      

      virtual  
      ~basic_istream()  
      { _M_gcount = streamsize(0); } 
 
            class sentry; 
      friend class sentry; 
 
                        

      inline __istream_type& 
      operator>>(__istream_type& (*__pf)(__istream_type&)); 
 
      inline __istream_type& 
      operator>>(__ios_type& (*__pf)(__ios_type&)); 
 
      inline __istream_type& 
      operator>>(ios_base& (*__pf)(ios_base&)); 
             
            

            

      __istream_type&  
      operator>>(bool& __n); 
       
      __istream_type&  
      operator>>(short& __n); 
       
      __istream_type&  
      operator>>(unsigned short& __n); 
 
      __istream_type&  
      operator>>(int& __n); 
       
      __istream_type&  
      operator>>(unsigned int& __n); 
 
      __istream_type&  
      operator>>(long& __n); 
       
      __istream_type&  
      operator>>(unsigned long& __n); 
 
#ifdef _GLIBCXX_USE_LONG_LONG 
      __istream_type&  
      operator>>(long long& __n); 
 
      __istream_type&  
      operator>>(unsigned long long& __n); 
#endif 
 
      __istream_type&  
      operator>>(float& __f); 
 
      __istream_type&  
      operator>>(double& __f); 
 
      __istream_type&  
      operator>>(long double& __f); 
 
      __istream_type&  
      operator>>(void*& __p); 
 
      

      __istream_type&  
      operator>>(__streambuf_type* __sb); 
             
            

      inline streamsize  
      gcount() const  
      { return _M_gcount; } 
       
      

            

      int_type  
      get(); 
 
      

      __istream_type&  
      get(char_type& __c); 
 
      

      __istream_type&  
      get(char_type* __s, streamsize __n, char_type __delim); 
 
      

      inline __istream_type&  
      get(char_type* __s, streamsize __n) 
      { return this->get(__s, __n, this->widen('\n')); } 
 
      

      __istream_type& 
      get(__streambuf_type& __sb, char_type __delim); 
 
      

      inline __istream_type& 
      get(__streambuf_type& __sb) 
      { return this->get(__sb, this->widen('\n')); } 
 
      

      __istream_type&  
      getline(char_type* __s, streamsize __n, char_type __delim); 
 
      

      inline __istream_type&  
      getline(char_type* __s, streamsize __n) 
      { return this->getline(__s, __n, this->widen('\n')); } 
 
      

      __istream_type&  
      ignore(); 
 
      __istream_type&  
      ignore(streamsize __n); 
 
      __istream_type&  
      ignore(streamsize __n, int_type __delim); 
       
      

      int_type  
      peek(); 
       
      

      __istream_type&  
      read(char_type* __s, streamsize __n); 
 
      

      streamsize  
      readsome(char_type* __s, streamsize __n); 
       
      

      __istream_type&  
      putback(char_type __c); 
 
      

      __istream_type&  
      unget(); 
 
      

      int  
      sync(); 
 
      

      pos_type  
      tellg(); 
 
      

      __istream_type&  
      seekg(pos_type); 
 
      

      __istream_type&  
      seekg(off_type, ios_base::seekdir); 
       
    protected: 
      explicit  
      basic_istream(): _M_gcount(streamsize(0)) { } 
    }; 
 
    template<>  
    basic_istream<char>&  
    basic_istream<char>:: 
    getline(char_type* __s, streamsize __n, char_type __delim); 
   
  template<> 
    basic_istream<char>& 
    basic_istream<char>:: 
    ignore(streamsize __n); 
   
  template<> 
    basic_istream<char>& 
    basic_istream<char>:: 
    ignore(streamsize __n, int_type __delim); 
 
#ifdef _GLIBCXX_USE_WCHAR_T 
  template<>  
    basic_istream<wchar_t>&  
    basic_istream<wchar_t>:: 
    getline(char_type* __s, streamsize __n, char_type __delim); 
 
  template<> 
    basic_istream<wchar_t>& 
    basic_istream<wchar_t>:: 
    ignore(streamsize __n); 
   
  template<> 
    basic_istream<wchar_t>& 
    basic_istream<wchar_t>:: 
    ignore(streamsize __n, int_type __delim); 
#endif 
 
  

  template<typename _CharT, typename _Traits> 
    class basic_istream<_CharT, _Traits>::sentry 
    { 
    public: 
            typedef _Traits 					traits_type; 
      typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type; 
      typedef basic_istream<_CharT, _Traits> 		__istream_type; 
      typedef typename __istream_type::__ctype_type 	__ctype_type; 
      typedef typename _Traits::int_type		__int_type; 
 
      

      explicit  
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false); 
 
      

      operator bool() const { return _M_ok; } 
 
    private: 
      bool _M_ok; 
    }; 
 
      

  template<typename _CharT, typename _Traits> 
    basic_istream<_CharT, _Traits>& 
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c); 
 
  template<class _Traits> 
    basic_istream<char, _Traits>& 
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c) 
    { return (__in >> reinterpret_cast<char&>(__c)); } 
 
  template<class _Traits> 
    basic_istream<char, _Traits>& 
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c) 
    { return (__in >> reinterpret_cast<char&>(__c)); } 
   
    

  template<typename _CharT, typename _Traits> 
    basic_istream<_CharT, _Traits>& 
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s); 
 
    template<> 
    basic_istream<char>& 
    operator>>(basic_istream<char>& __in, char* __s); 
 
  template<class _Traits> 
    basic_istream<char, _Traits>& 
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s) 
    { return (__in >> reinterpret_cast<char*>(__s)); } 
 
  template<class _Traits> 
    basic_istream<char, _Traits>& 
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s) 
    { return (__in >> reinterpret_cast<char*>(__s)); } 
   
    

  template<typename _CharT, typename _Traits> 
    class basic_iostream 
    : public basic_istream<_CharT, _Traits>,  
      public basic_ostream<_CharT, _Traits> 
    { 
    public: 
                        typedef _CharT                     		char_type; 
      typedef typename _Traits::int_type 		int_type; 
      typedef typename _Traits::pos_type 		pos_type; 
      typedef typename _Traits::off_type 		off_type; 
      typedef _Traits                    		traits_type; 
 
            typedef basic_istream<_CharT, _Traits>		__istream_type; 
      typedef basic_ostream<_CharT, _Traits>		__ostream_type; 
 
      

      explicit  
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb) 
      : __istream_type(), __ostream_type() 
      { this->init(__sb); } 
 
      

      virtual  
      ~basic_iostream() { } 
 
    protected: 
      explicit  
      basic_iostream() : __istream_type(), __ostream_type() 
      { } 
    }; 
 
    

  template<typename _CharT, typename _Traits> 
    basic_istream<_CharT, _Traits>&  
    ws(basic_istream<_CharT, _Traits>& __is); 
}  
#ifndef _GLIBCXX_EXPORT_TEMPLATE 
# include <bits/istream.tcc> 
#endif 
 
#endif	
 
namespace std  
{ 
  

    extern istream cin;		  extern ostream cout;		  extern ostream cerr;		  extern ostream clog;		 
#ifdef _GLIBCXX_USE_WCHAR_T 
  extern wistream wcin;		  extern wostream wcout;	  extern wostream wcerr;	  extern wostream wclog;	#endif 
   
    static ios_base::Init __ioinit; 
}  
#endif 
using namespace std; 
 
class Custom 
{ 
 
private: 
    string sentence; 
    int number; 
 
 
public: 
 
Custom() 
:sentence(""),number(0) 
{} 
 
Custom(string s) 
:sentence(s),number(0) 
{} 
 
Custom(int n) 
:sentence(""),number(n) 
{} 
 
Custom(string s, int n) 
:sentence(s),number(n) 
{} 
 
 
}; 
 
using namespace std; 
 
  int main() 
{ 
    

    string s = "Program terminated";

    cout << "Hello World " << s << endl; 
 
    cout << 1000 << endl; 
 
    cout << "WONGWORLD!" << "WONGWORLD!" << " " << "WONGWORLD!" << endl; 
    cout << xx << endl; 
 
 
    return 0;} 
 
